//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.14.0
// source: ebpf/accesslog.proto

package v3

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	v3 "github.com/apache/skywalking-go/protocols/collect/common/v3"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ZTunnelAttachmentEnvironmentDetectBy int32

const (
	ZTunnelAttachmentEnvironmentDetectBy_ZTUNNEL_OUTBOUND_FUNC ZTunnelAttachmentEnvironmentDetectBy = 0
	ZTunnelAttachmentEnvironmentDetectBy_ZTUNNEL_INBOUND_FUNC  ZTunnelAttachmentEnvironmentDetectBy = 1
)

// Enum value maps for ZTunnelAttachmentEnvironmentDetectBy.
var (
	ZTunnelAttachmentEnvironmentDetectBy_name = map[int32]string{
		0: "ZTUNNEL_OUTBOUND_FUNC",
		1: "ZTUNNEL_INBOUND_FUNC",
	}
	ZTunnelAttachmentEnvironmentDetectBy_value = map[string]int32{
		"ZTUNNEL_OUTBOUND_FUNC": 0,
		"ZTUNNEL_INBOUND_FUNC":  1,
	}
)

func (x ZTunnelAttachmentEnvironmentDetectBy) Enum() *ZTunnelAttachmentEnvironmentDetectBy {
	p := new(ZTunnelAttachmentEnvironmentDetectBy)
	*p = x
	return p
}

func (x ZTunnelAttachmentEnvironmentDetectBy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ZTunnelAttachmentEnvironmentDetectBy) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[0].Descriptor()
}

func (ZTunnelAttachmentEnvironmentDetectBy) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[0]
}

func (x ZTunnelAttachmentEnvironmentDetectBy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ZTunnelAttachmentEnvironmentDetectBy.Descriptor instead.
func (ZTunnelAttachmentEnvironmentDetectBy) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{0}
}

type ZTunnelAttachmentSecurityPolicy int32

const (
	ZTunnelAttachmentSecurityPolicy_MTLS ZTunnelAttachmentSecurityPolicy = 0
	ZTunnelAttachmentSecurityPolicy_NONE ZTunnelAttachmentSecurityPolicy = 1
)

// Enum value maps for ZTunnelAttachmentSecurityPolicy.
var (
	ZTunnelAttachmentSecurityPolicy_name = map[int32]string{
		0: "MTLS",
		1: "NONE",
	}
	ZTunnelAttachmentSecurityPolicy_value = map[string]int32{
		"MTLS": 0,
		"NONE": 1,
	}
)

func (x ZTunnelAttachmentSecurityPolicy) Enum() *ZTunnelAttachmentSecurityPolicy {
	p := new(ZTunnelAttachmentSecurityPolicy)
	*p = x
	return p
}

func (x ZTunnelAttachmentSecurityPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ZTunnelAttachmentSecurityPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[1].Descriptor()
}

func (ZTunnelAttachmentSecurityPolicy) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[1]
}

func (x ZTunnelAttachmentSecurityPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ZTunnelAttachmentSecurityPolicy.Descriptor instead.
func (ZTunnelAttachmentSecurityPolicy) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{1}
}

type AccessLogConnectionTLSMode int32

const (
	AccessLogConnectionTLSMode_Plain AccessLogConnectionTLSMode = 0
	AccessLogConnectionTLSMode_TLS   AccessLogConnectionTLSMode = 1
)

// Enum value maps for AccessLogConnectionTLSMode.
var (
	AccessLogConnectionTLSMode_name = map[int32]string{
		0: "Plain",
		1: "TLS",
	}
	AccessLogConnectionTLSMode_value = map[string]int32{
		"Plain": 0,
		"TLS":   1,
	}
)

func (x AccessLogConnectionTLSMode) Enum() *AccessLogConnectionTLSMode {
	p := new(AccessLogConnectionTLSMode)
	*p = x
	return p
}

func (x AccessLogConnectionTLSMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AccessLogConnectionTLSMode) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[2].Descriptor()
}

func (AccessLogConnectionTLSMode) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[2]
}

func (x AccessLogConnectionTLSMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AccessLogConnectionTLSMode.Descriptor instead.
func (AccessLogConnectionTLSMode) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{2}
}

type AccessLogHTTPProtocolVersion int32

const (
	AccessLogHTTPProtocolVersion_HTTP1 AccessLogHTTPProtocolVersion = 0
	AccessLogHTTPProtocolVersion_HTTP2 AccessLogHTTPProtocolVersion = 1
)

// Enum value maps for AccessLogHTTPProtocolVersion.
var (
	AccessLogHTTPProtocolVersion_name = map[int32]string{
		0: "HTTP1",
		1: "HTTP2",
	}
	AccessLogHTTPProtocolVersion_value = map[string]int32{
		"HTTP1": 0,
		"HTTP2": 1,
	}
)

func (x AccessLogHTTPProtocolVersion) Enum() *AccessLogHTTPProtocolVersion {
	p := new(AccessLogHTTPProtocolVersion)
	*p = x
	return p
}

func (x AccessLogHTTPProtocolVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AccessLogHTTPProtocolVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[3].Descriptor()
}

func (AccessLogHTTPProtocolVersion) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[3]
}

func (x AccessLogHTTPProtocolVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AccessLogHTTPProtocolVersion.Descriptor instead.
func (AccessLogHTTPProtocolVersion) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{3}
}

type AccessLogTraceInfoProvider int32

const (
	AccessLogTraceInfoProvider_Zipkin     AccessLogTraceInfoProvider = 0
	AccessLogTraceInfoProvider_SkyWalking AccessLogTraceInfoProvider = 1
)

// Enum value maps for AccessLogTraceInfoProvider.
var (
	AccessLogTraceInfoProvider_name = map[int32]string{
		0: "Zipkin",
		1: "SkyWalking",
	}
	AccessLogTraceInfoProvider_value = map[string]int32{
		"Zipkin":     0,
		"SkyWalking": 1,
	}
)

func (x AccessLogTraceInfoProvider) Enum() *AccessLogTraceInfoProvider {
	p := new(AccessLogTraceInfoProvider)
	*p = x
	return p
}

func (x AccessLogTraceInfoProvider) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AccessLogTraceInfoProvider) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[4].Descriptor()
}

func (AccessLogTraceInfoProvider) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[4]
}

func (x AccessLogTraceInfoProvider) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AccessLogTraceInfoProvider.Descriptor instead.
func (AccessLogTraceInfoProvider) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{4}
}

type AccessLogHTTPProtocolRequestMethod int32

const (
	AccessLogHTTPProtocolRequestMethod_Get     AccessLogHTTPProtocolRequestMethod = 0
	AccessLogHTTPProtocolRequestMethod_Post    AccessLogHTTPProtocolRequestMethod = 1
	AccessLogHTTPProtocolRequestMethod_Put     AccessLogHTTPProtocolRequestMethod = 2
	AccessLogHTTPProtocolRequestMethod_Delete  AccessLogHTTPProtocolRequestMethod = 3
	AccessLogHTTPProtocolRequestMethod_Head    AccessLogHTTPProtocolRequestMethod = 4
	AccessLogHTTPProtocolRequestMethod_Patch   AccessLogHTTPProtocolRequestMethod = 5
	AccessLogHTTPProtocolRequestMethod_Options AccessLogHTTPProtocolRequestMethod = 6
	AccessLogHTTPProtocolRequestMethod_Trace   AccessLogHTTPProtocolRequestMethod = 7
	AccessLogHTTPProtocolRequestMethod_Connect AccessLogHTTPProtocolRequestMethod = 8
)

// Enum value maps for AccessLogHTTPProtocolRequestMethod.
var (
	AccessLogHTTPProtocolRequestMethod_name = map[int32]string{
		0: "Get",
		1: "Post",
		2: "Put",
		3: "Delete",
		4: "Head",
		5: "Patch",
		6: "Options",
		7: "Trace",
		8: "Connect",
	}
	AccessLogHTTPProtocolRequestMethod_value = map[string]int32{
		"Get":     0,
		"Post":    1,
		"Put":     2,
		"Delete":  3,
		"Head":    4,
		"Patch":   5,
		"Options": 6,
		"Trace":   7,
		"Connect": 8,
	}
)

func (x AccessLogHTTPProtocolRequestMethod) Enum() *AccessLogHTTPProtocolRequestMethod {
	p := new(AccessLogHTTPProtocolRequestMethod)
	*p = x
	return p
}

func (x AccessLogHTTPProtocolRequestMethod) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AccessLogHTTPProtocolRequestMethod) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[5].Descriptor()
}

func (AccessLogHTTPProtocolRequestMethod) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[5]
}

func (x AccessLogHTTPProtocolRequestMethod) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AccessLogHTTPProtocolRequestMethod.Descriptor instead.
func (AccessLogHTTPProtocolRequestMethod) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{5}
}

type AccessLogKernelWriteSyscall int32

const (
	AccessLogKernelWriteSyscall_Write      AccessLogKernelWriteSyscall = 0
	AccessLogKernelWriteSyscall_Writev     AccessLogKernelWriteSyscall = 1
	AccessLogKernelWriteSyscall_Send       AccessLogKernelWriteSyscall = 2
	AccessLogKernelWriteSyscall_SendTo     AccessLogKernelWriteSyscall = 3
	AccessLogKernelWriteSyscall_SendMsg    AccessLogKernelWriteSyscall = 4
	AccessLogKernelWriteSyscall_SendMmsg   AccessLogKernelWriteSyscall = 5
	AccessLogKernelWriteSyscall_SendFile   AccessLogKernelWriteSyscall = 6
	AccessLogKernelWriteSyscall_SendFile64 AccessLogKernelWriteSyscall = 7
)

// Enum value maps for AccessLogKernelWriteSyscall.
var (
	AccessLogKernelWriteSyscall_name = map[int32]string{
		0: "Write",
		1: "Writev",
		2: "Send",
		3: "SendTo",
		4: "SendMsg",
		5: "SendMmsg",
		6: "SendFile",
		7: "SendFile64",
	}
	AccessLogKernelWriteSyscall_value = map[string]int32{
		"Write":      0,
		"Writev":     1,
		"Send":       2,
		"SendTo":     3,
		"SendMsg":    4,
		"SendMmsg":   5,
		"SendFile":   6,
		"SendFile64": 7,
	}
)

func (x AccessLogKernelWriteSyscall) Enum() *AccessLogKernelWriteSyscall {
	p := new(AccessLogKernelWriteSyscall)
	*p = x
	return p
}

func (x AccessLogKernelWriteSyscall) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AccessLogKernelWriteSyscall) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[6].Descriptor()
}

func (AccessLogKernelWriteSyscall) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[6]
}

func (x AccessLogKernelWriteSyscall) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AccessLogKernelWriteSyscall.Descriptor instead.
func (AccessLogKernelWriteSyscall) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{6}
}

type AccessLogKernelReadSyscall int32

const (
	AccessLogKernelReadSyscall_Read     AccessLogKernelReadSyscall = 0
	AccessLogKernelReadSyscall_Readv    AccessLogKernelReadSyscall = 1
	AccessLogKernelReadSyscall_Recv     AccessLogKernelReadSyscall = 2
	AccessLogKernelReadSyscall_RecvFrom AccessLogKernelReadSyscall = 3
	AccessLogKernelReadSyscall_RecvMsg  AccessLogKernelReadSyscall = 4
	AccessLogKernelReadSyscall_RecvMmsg AccessLogKernelReadSyscall = 5
)

// Enum value maps for AccessLogKernelReadSyscall.
var (
	AccessLogKernelReadSyscall_name = map[int32]string{
		0: "Read",
		1: "Readv",
		2: "Recv",
		3: "RecvFrom",
		4: "RecvMsg",
		5: "RecvMmsg",
	}
	AccessLogKernelReadSyscall_value = map[string]int32{
		"Read":     0,
		"Readv":    1,
		"Recv":     2,
		"RecvFrom": 3,
		"RecvMsg":  4,
		"RecvMmsg": 5,
	}
)

func (x AccessLogKernelReadSyscall) Enum() *AccessLogKernelReadSyscall {
	p := new(AccessLogKernelReadSyscall)
	*p = x
	return p
}

func (x AccessLogKernelReadSyscall) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AccessLogKernelReadSyscall) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[7].Descriptor()
}

func (AccessLogKernelReadSyscall) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[7]
}

func (x AccessLogKernelReadSyscall) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AccessLogKernelReadSyscall.Descriptor instead.
func (AccessLogKernelReadSyscall) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{7}
}

type AccessLogProtocolType int32

const (
	AccessLogProtocolType_TCP    AccessLogProtocolType = 0
	AccessLogProtocolType_HTTP_1 AccessLogProtocolType = 1
	AccessLogProtocolType_HTTP_2 AccessLogProtocolType = 2
)

// Enum value maps for AccessLogProtocolType.
var (
	AccessLogProtocolType_name = map[int32]string{
		0: "TCP",
		1: "HTTP_1",
		2: "HTTP_2",
	}
	AccessLogProtocolType_value = map[string]int32{
		"TCP":    0,
		"HTTP_1": 1,
		"HTTP_2": 2,
	}
)

func (x AccessLogProtocolType) Enum() *AccessLogProtocolType {
	p := new(AccessLogProtocolType)
	*p = x
	return p
}

func (x AccessLogProtocolType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AccessLogProtocolType) Descriptor() protoreflect.EnumDescriptor {
	return file_ebpf_accesslog_proto_enumTypes[8].Descriptor()
}

func (AccessLogProtocolType) Type() protoreflect.EnumType {
	return &file_ebpf_accesslog_proto_enumTypes[8]
}

func (x AccessLogProtocolType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AccessLogProtocolType.Descriptor instead.
func (AccessLogProtocolType) EnumDescriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{8}
}

type EBPFAccessLogMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// current node information, only not null when first message or have update
	Node *EBPFAccessLogNodeInfo `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	// local process and remote process connection information
	Connection *AccessLogConnection `protobuf:"bytes,2,opt,name=connection,proto3" json:"connection,omitempty"`
	// kernel level metrics
	KernelLogs []*AccessLogKernelLog `protobuf:"bytes,3,rep,name=kernelLogs,proto3" json:"kernelLogs,omitempty"`
	// application protocol log
	// if the protocol is detected, the kernel logs is works the related logs
	// otherwise, the kernel log is not related and is sent periodically
	ProtocolLog *AccessLogProtocolLogs `protobuf:"bytes,4,opt,name=protocolLog,proto3" json:"protocolLog,omitempty"`
}

func (x *EBPFAccessLogMessage) Reset() {
	*x = EBPFAccessLogMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EBPFAccessLogMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EBPFAccessLogMessage) ProtoMessage() {}

func (x *EBPFAccessLogMessage) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EBPFAccessLogMessage.ProtoReflect.Descriptor instead.
func (*EBPFAccessLogMessage) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{0}
}

func (x *EBPFAccessLogMessage) GetNode() *EBPFAccessLogNodeInfo {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *EBPFAccessLogMessage) GetConnection() *AccessLogConnection {
	if x != nil {
		return x.Connection
	}
	return nil
}

func (x *EBPFAccessLogMessage) GetKernelLogs() []*AccessLogKernelLog {
	if x != nil {
		return x.KernelLogs
	}
	return nil
}

func (x *EBPFAccessLogMessage) GetProtocolLog() *AccessLogProtocolLogs {
	if x != nil {
		return x.ProtocolLog
	}
	return nil
}

type EBPFAccessLogNodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Node name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// All net interfaces list
	NetInterfaces []*EBPFAccessLogNodeNetInterface `protobuf:"bytes,2,rep,name=netInterfaces,proto3" json:"netInterfaces,omitempty"`
	// System boot time
	BootTime *v3.Instant `protobuf:"bytes,3,opt,name=bootTime,proto3" json:"bootTime,omitempty"`
	// Cluster name
	ClusterName string `protobuf:"bytes,4,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	// Policy for the access log
	Policy *EBPFAccessLogPolicy `protobuf:"bytes,5,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (x *EBPFAccessLogNodeInfo) Reset() {
	*x = EBPFAccessLogNodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EBPFAccessLogNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EBPFAccessLogNodeInfo) ProtoMessage() {}

func (x *EBPFAccessLogNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EBPFAccessLogNodeInfo.ProtoReflect.Descriptor instead.
func (*EBPFAccessLogNodeInfo) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{1}
}

func (x *EBPFAccessLogNodeInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EBPFAccessLogNodeInfo) GetNetInterfaces() []*EBPFAccessLogNodeNetInterface {
	if x != nil {
		return x.NetInterfaces
	}
	return nil
}

func (x *EBPFAccessLogNodeInfo) GetBootTime() *v3.Instant {
	if x != nil {
		return x.BootTime
	}
	return nil
}

func (x *EBPFAccessLogNodeInfo) GetClusterName() string {
	if x != nil {
		return x.ClusterName
	}
	return ""
}

func (x *EBPFAccessLogNodeInfo) GetPolicy() *EBPFAccessLogPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

type EBPFAccessLogPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Which namespaces should be excluded to generate the connection
	ExcludeNamespaces []string `protobuf:"bytes,1,rep,name=excludeNamespaces,proto3" json:"excludeNamespaces,omitempty"`
}

func (x *EBPFAccessLogPolicy) Reset() {
	*x = EBPFAccessLogPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EBPFAccessLogPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EBPFAccessLogPolicy) ProtoMessage() {}

func (x *EBPFAccessLogPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EBPFAccessLogPolicy.ProtoReflect.Descriptor instead.
func (*EBPFAccessLogPolicy) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{2}
}

func (x *EBPFAccessLogPolicy) GetExcludeNamespaces() []string {
	if x != nil {
		return x.ExcludeNamespaces
	}
	return nil
}

type EBPFAccessLogNodeNetInterface struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Index int32  `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Mtu   int32  `protobuf:"varint,2,opt,name=mtu,proto3" json:"mtu,omitempty"`
	Name  string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *EBPFAccessLogNodeNetInterface) Reset() {
	*x = EBPFAccessLogNodeNetInterface{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EBPFAccessLogNodeNetInterface) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EBPFAccessLogNodeNetInterface) ProtoMessage() {}

func (x *EBPFAccessLogNodeNetInterface) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EBPFAccessLogNodeNetInterface.ProtoReflect.Descriptor instead.
func (*EBPFAccessLogNodeNetInterface) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{3}
}

func (x *EBPFAccessLogNodeNetInterface) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *EBPFAccessLogNodeNetInterface) GetMtu() int32 {
	if x != nil {
		return x.Mtu
	}
	return 0
}

func (x *EBPFAccessLogNodeNetInterface) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Connection information
type AccessLogConnection struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// local address
	Local *ConnectionAddress `protobuf:"bytes,1,opt,name=local,proto3" json:"local,omitempty"`
	// remote/peer address
	Remote *ConnectionAddress `protobuf:"bytes,2,opt,name=remote,proto3" json:"remote,omitempty"`
	// local address detect point
	Role v3.DetectPoint `protobuf:"varint,3,opt,name=role,proto3,enum=skywalking.v3.DetectPoint" json:"role,omitempty"`
	// is the connection using TLS or not
	TlsMode AccessLogConnectionTLSMode `protobuf:"varint,4,opt,name=tlsMode,proto3,enum=skywalking.v3.AccessLogConnectionTLSMode" json:"tlsMode,omitempty"`
	// application protocol type
	Protocol AccessLogProtocolType `protobuf:"varint,5,opt,name=protocol,proto3,enum=skywalking.v3.AccessLogProtocolType" json:"protocol,omitempty"`
	// the attachment information about the connection
	Attachment *ConnectionAttachment `protobuf:"bytes,6,opt,name=attachment,proto3" json:"attachment,omitempty"`
}

func (x *AccessLogConnection) Reset() {
	*x = AccessLogConnection{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogConnection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogConnection) ProtoMessage() {}

func (x *AccessLogConnection) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogConnection.ProtoReflect.Descriptor instead.
func (*AccessLogConnection) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{4}
}

func (x *AccessLogConnection) GetLocal() *ConnectionAddress {
	if x != nil {
		return x.Local
	}
	return nil
}

func (x *AccessLogConnection) GetRemote() *ConnectionAddress {
	if x != nil {
		return x.Remote
	}
	return nil
}

func (x *AccessLogConnection) GetRole() v3.DetectPoint {
	if x != nil {
		return x.Role
	}
	return v3.DetectPoint_client
}

func (x *AccessLogConnection) GetTlsMode() AccessLogConnectionTLSMode {
	if x != nil {
		return x.TlsMode
	}
	return AccessLogConnectionTLSMode_Plain
}

func (x *AccessLogConnection) GetProtocol() AccessLogProtocolType {
	if x != nil {
		return x.Protocol
	}
	return AccessLogProtocolType_TCP
}

func (x *AccessLogConnection) GetAttachment() *ConnectionAttachment {
	if x != nil {
		return x.Attachment
	}
	return nil
}

type ConnectionAttachment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// detect contains the environment information
	//
	// Types that are assignable to Environment:
	//
	//	*ConnectionAttachment_ZTunnel
	Environment isConnectionAttachment_Environment `protobuf_oneof:"environment"`
}

func (x *ConnectionAttachment) Reset() {
	*x = ConnectionAttachment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConnectionAttachment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectionAttachment) ProtoMessage() {}

func (x *ConnectionAttachment) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectionAttachment.ProtoReflect.Descriptor instead.
func (*ConnectionAttachment) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{5}
}

func (m *ConnectionAttachment) GetEnvironment() isConnectionAttachment_Environment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (x *ConnectionAttachment) GetZTunnel() *ZTunnelAttachmentEnvironment {
	if x, ok := x.GetEnvironment().(*ConnectionAttachment_ZTunnel); ok {
		return x.ZTunnel
	}
	return nil
}

type isConnectionAttachment_Environment interface {
	isConnectionAttachment_Environment()
}

type ConnectionAttachment_ZTunnel struct {
	// detect the connection have a zTunnel environment(ambient istio)
	ZTunnel *ZTunnelAttachmentEnvironment `protobuf:"bytes,1,opt,name=zTunnel,proto3,oneof"`
}

func (*ConnectionAttachment_ZTunnel) isConnectionAttachment_Environment() {}

type ZTunnelAttachmentEnvironment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// the real destination ip address of the connection
	RealDestinationIp string `protobuf:"bytes,1,opt,name=real_destination_ip,json=realDestinationIp,proto3" json:"real_destination_ip,omitempty"`
	// how the environment detected
	// if detect by inbound, then the real destination ip is empty
	By ZTunnelAttachmentEnvironmentDetectBy `protobuf:"varint,2,opt,name=by,proto3,enum=skywalking.v3.ZTunnelAttachmentEnvironmentDetectBy" json:"by,omitempty"`
	// the security policy of the ztunnel communicate with upstream
	SecurityPolicy ZTunnelAttachmentSecurityPolicy `protobuf:"varint,3,opt,name=security_policy,json=securityPolicy,proto3,enum=skywalking.v3.ZTunnelAttachmentSecurityPolicy" json:"security_policy,omitempty"`
}

func (x *ZTunnelAttachmentEnvironment) Reset() {
	*x = ZTunnelAttachmentEnvironment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ZTunnelAttachmentEnvironment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZTunnelAttachmentEnvironment) ProtoMessage() {}

func (x *ZTunnelAttachmentEnvironment) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZTunnelAttachmentEnvironment.ProtoReflect.Descriptor instead.
func (*ZTunnelAttachmentEnvironment) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{6}
}

func (x *ZTunnelAttachmentEnvironment) GetRealDestinationIp() string {
	if x != nil {
		return x.RealDestinationIp
	}
	return ""
}

func (x *ZTunnelAttachmentEnvironment) GetBy() ZTunnelAttachmentEnvironmentDetectBy {
	if x != nil {
		return x.By
	}
	return ZTunnelAttachmentEnvironmentDetectBy_ZTUNNEL_OUTBOUND_FUNC
}

func (x *ZTunnelAttachmentEnvironment) GetSecurityPolicy() ZTunnelAttachmentSecurityPolicy {
	if x != nil {
		return x.SecurityPolicy
	}
	return ZTunnelAttachmentSecurityPolicy_MTLS
}

type ConnectionAddress struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Address:
	//
	//	*ConnectionAddress_Kubernetes
	//	*ConnectionAddress_Ip
	Address isConnectionAddress_Address `protobuf_oneof:"address"`
}

func (x *ConnectionAddress) Reset() {
	*x = ConnectionAddress{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConnectionAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectionAddress) ProtoMessage() {}

func (x *ConnectionAddress) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectionAddress.ProtoReflect.Descriptor instead.
func (*ConnectionAddress) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{7}
}

func (m *ConnectionAddress) GetAddress() isConnectionAddress_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (x *ConnectionAddress) GetKubernetes() *KubernetesProcessAddress {
	if x, ok := x.GetAddress().(*ConnectionAddress_Kubernetes); ok {
		return x.Kubernetes
	}
	return nil
}

func (x *ConnectionAddress) GetIp() *IPAddress {
	if x, ok := x.GetAddress().(*ConnectionAddress_Ip); ok {
		return x.Ip
	}
	return nil
}

type isConnectionAddress_Address interface {
	isConnectionAddress_Address()
}

type ConnectionAddress_Kubernetes struct {
	// if the address is monitored under the local machine, then return the kubernetes
	Kubernetes *KubernetesProcessAddress `protobuf:"bytes,1,opt,name=kubernetes,proto3,oneof"`
}

type ConnectionAddress_Ip struct {
	// if the address cannot be aware, then return the ip address
	Ip *IPAddress `protobuf:"bytes,2,opt,name=ip,proto3,oneof"`
}

func (*ConnectionAddress_Kubernetes) isConnectionAddress_Address() {}

func (*ConnectionAddress_Ip) isConnectionAddress_Address() {}

type KubernetesProcessAddress struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ServiceName   string `protobuf:"bytes,1,opt,name=serviceName,proto3" json:"serviceName,omitempty"`
	PodName       string `protobuf:"bytes,2,opt,name=podName,proto3" json:"podName,omitempty"`
	ContainerName string `protobuf:"bytes,3,opt,name=containerName,proto3" json:"containerName,omitempty"`
	ProcessName   string `protobuf:"bytes,4,opt,name=processName,proto3" json:"processName,omitempty"`
	Port          int32  `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
}

func (x *KubernetesProcessAddress) Reset() {
	*x = KubernetesProcessAddress{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *KubernetesProcessAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesProcessAddress) ProtoMessage() {}

func (x *KubernetesProcessAddress) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesProcessAddress.ProtoReflect.Descriptor instead.
func (*KubernetesProcessAddress) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{8}
}

func (x *KubernetesProcessAddress) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *KubernetesProcessAddress) GetPodName() string {
	if x != nil {
		return x.PodName
	}
	return ""
}

func (x *KubernetesProcessAddress) GetContainerName() string {
	if x != nil {
		return x.ContainerName
	}
	return ""
}

func (x *KubernetesProcessAddress) GetProcessName() string {
	if x != nil {
		return x.ProcessName
	}
	return ""
}

func (x *KubernetesProcessAddress) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

type IPAddress struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (x *IPAddress) Reset() {
	*x = IPAddress{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPAddress) ProtoMessage() {}

func (x *IPAddress) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPAddress.ProtoReflect.Descriptor instead.
func (*IPAddress) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{9}
}

func (x *IPAddress) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *IPAddress) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

type AccessLogKernelLog struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Operation:
	//
	//	*AccessLogKernelLog_Connect
	//	*AccessLogKernelLog_Accept
	//	*AccessLogKernelLog_Close
	//	*AccessLogKernelLog_Read
	//	*AccessLogKernelLog_Write
	Operation isAccessLogKernelLog_Operation `protobuf_oneof:"operation"`
}

func (x *AccessLogKernelLog) Reset() {
	*x = AccessLogKernelLog{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelLog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelLog) ProtoMessage() {}

func (x *AccessLogKernelLog) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelLog.ProtoReflect.Descriptor instead.
func (*AccessLogKernelLog) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{10}
}

func (m *AccessLogKernelLog) GetOperation() isAccessLogKernelLog_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (x *AccessLogKernelLog) GetConnect() *AccessLogKernelConnectOperation {
	if x, ok := x.GetOperation().(*AccessLogKernelLog_Connect); ok {
		return x.Connect
	}
	return nil
}

func (x *AccessLogKernelLog) GetAccept() *AccessLogKernelAcceptOperation {
	if x, ok := x.GetOperation().(*AccessLogKernelLog_Accept); ok {
		return x.Accept
	}
	return nil
}

func (x *AccessLogKernelLog) GetClose() *AccessLogKernelCloseOperation {
	if x, ok := x.GetOperation().(*AccessLogKernelLog_Close); ok {
		return x.Close
	}
	return nil
}

func (x *AccessLogKernelLog) GetRead() *AccessLogKernelReadOperation {
	if x, ok := x.GetOperation().(*AccessLogKernelLog_Read); ok {
		return x.Read
	}
	return nil
}

func (x *AccessLogKernelLog) GetWrite() *AccessLogKernelWriteOperation {
	if x, ok := x.GetOperation().(*AccessLogKernelLog_Write); ok {
		return x.Write
	}
	return nil
}

type isAccessLogKernelLog_Operation interface {
	isAccessLogKernelLog_Operation()
}

type AccessLogKernelLog_Connect struct {
	Connect *AccessLogKernelConnectOperation `protobuf:"bytes,1,opt,name=connect,proto3,oneof"`
}

type AccessLogKernelLog_Accept struct {
	Accept *AccessLogKernelAcceptOperation `protobuf:"bytes,2,opt,name=accept,proto3,oneof"`
}

type AccessLogKernelLog_Close struct {
	Close *AccessLogKernelCloseOperation `protobuf:"bytes,3,opt,name=close,proto3,oneof"`
}

type AccessLogKernelLog_Read struct {
	Read *AccessLogKernelReadOperation `protobuf:"bytes,4,opt,name=read,proto3,oneof"`
}

type AccessLogKernelLog_Write struct {
	Write *AccessLogKernelWriteOperation `protobuf:"bytes,5,opt,name=write,proto3,oneof"`
}

func (*AccessLogKernelLog_Connect) isAccessLogKernelLog_Operation() {}

func (*AccessLogKernelLog_Accept) isAccessLogKernelLog_Operation() {}

func (*AccessLogKernelLog_Close) isAccessLogKernelLog_Operation() {}

func (*AccessLogKernelLog_Read) isAccessLogKernelLog_Operation() {}

func (*AccessLogKernelLog_Write) isAccessLogKernelLog_Operation() {}

type AccessLogProtocolLogs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Protocol:
	//
	//	*AccessLogProtocolLogs_Http
	Protocol isAccessLogProtocolLogs_Protocol `protobuf_oneof:"protocol"`
}

func (x *AccessLogProtocolLogs) Reset() {
	*x = AccessLogProtocolLogs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogProtocolLogs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogProtocolLogs) ProtoMessage() {}

func (x *AccessLogProtocolLogs) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogProtocolLogs.ProtoReflect.Descriptor instead.
func (*AccessLogProtocolLogs) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{11}
}

func (m *AccessLogProtocolLogs) GetProtocol() isAccessLogProtocolLogs_Protocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (x *AccessLogProtocolLogs) GetHttp() *AccessLogHTTPProtocol {
	if x, ok := x.GetProtocol().(*AccessLogProtocolLogs_Http); ok {
		return x.Http
	}
	return nil
}

type isAccessLogProtocolLogs_Protocol interface {
	isAccessLogProtocolLogs_Protocol()
}

type AccessLogProtocolLogs_Http struct {
	Http *AccessLogHTTPProtocol `protobuf:"bytes,1,opt,name=http,proto3,oneof"`
}

func (*AccessLogProtocolLogs_Http) isAccessLogProtocolLogs_Protocol() {}

type AccessLogHTTPProtocol struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// first bytes receive/write timestamp
	StartTime *EBPFTimestamp `protobuf:"bytes,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// last bytes receive/write timestamp
	EndTime  *EBPFTimestamp                 `protobuf:"bytes,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	Version  AccessLogHTTPProtocolVersion   `protobuf:"varint,3,opt,name=version,proto3,enum=skywalking.v3.AccessLogHTTPProtocolVersion" json:"version,omitempty"`
	Request  *AccessLogHTTPProtocolRequest  `protobuf:"bytes,4,opt,name=request,proto3" json:"request,omitempty"`
	Response *AccessLogHTTPProtocolResponse `protobuf:"bytes,5,opt,name=response,proto3" json:"response,omitempty"`
}

func (x *AccessLogHTTPProtocol) Reset() {
	*x = AccessLogHTTPProtocol{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogHTTPProtocol) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogHTTPProtocol) ProtoMessage() {}

func (x *AccessLogHTTPProtocol) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogHTTPProtocol.ProtoReflect.Descriptor instead.
func (*AccessLogHTTPProtocol) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{12}
}

func (x *AccessLogHTTPProtocol) GetStartTime() *EBPFTimestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *AccessLogHTTPProtocol) GetEndTime() *EBPFTimestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *AccessLogHTTPProtocol) GetVersion() AccessLogHTTPProtocolVersion {
	if x != nil {
		return x.Version
	}
	return AccessLogHTTPProtocolVersion_HTTP1
}

func (x *AccessLogHTTPProtocol) GetRequest() *AccessLogHTTPProtocolRequest {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *AccessLogHTTPProtocol) GetResponse() *AccessLogHTTPProtocolResponse {
	if x != nil {
		return x.Response
	}
	return nil
}

type AccessLogHTTPProtocolRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Method AccessLogHTTPProtocolRequestMethod `protobuf:"varint,1,opt,name=method,proto3,enum=skywalking.v3.AccessLogHTTPProtocolRequestMethod" json:"method,omitempty"`
	// The path portion from the incoming request URI.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Request header and body size.
	SizeOfHeadersBytes uint64 `protobuf:"varint,3,opt,name=sizeOfHeadersBytes,proto3" json:"sizeOfHeadersBytes,omitempty"`
	SizeOfBodyBytes    uint64 `protobuf:"varint,4,opt,name=sizeOfBodyBytes,proto3" json:"sizeOfBodyBytes,omitempty"`
	// The trace information if detected.
	Trace *AccessLogTraceInfo `protobuf:"bytes,5,opt,name=trace,proto3" json:"trace,omitempty"`
	// The host header of the incoming request.
	Host string `protobuf:"bytes,6,opt,name=host,proto3" json:"host,omitempty"`
}

func (x *AccessLogHTTPProtocolRequest) Reset() {
	*x = AccessLogHTTPProtocolRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogHTTPProtocolRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogHTTPProtocolRequest) ProtoMessage() {}

func (x *AccessLogHTTPProtocolRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogHTTPProtocolRequest.ProtoReflect.Descriptor instead.
func (*AccessLogHTTPProtocolRequest) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{13}
}

func (x *AccessLogHTTPProtocolRequest) GetMethod() AccessLogHTTPProtocolRequestMethod {
	if x != nil {
		return x.Method
	}
	return AccessLogHTTPProtocolRequestMethod_Get
}

func (x *AccessLogHTTPProtocolRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *AccessLogHTTPProtocolRequest) GetSizeOfHeadersBytes() uint64 {
	if x != nil {
		return x.SizeOfHeadersBytes
	}
	return 0
}

func (x *AccessLogHTTPProtocolRequest) GetSizeOfBodyBytes() uint64 {
	if x != nil {
		return x.SizeOfBodyBytes
	}
	return 0
}

func (x *AccessLogHTTPProtocolRequest) GetTrace() *AccessLogTraceInfo {
	if x != nil {
		return x.Trace
	}
	return nil
}

func (x *AccessLogHTTPProtocolRequest) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

type AccessLogHTTPProtocolResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StatusCode int32 `protobuf:"varint,1,opt,name=statusCode,proto3" json:"statusCode,omitempty"`
	// Response header and body size.
	SizeOfHeadersBytes uint64 `protobuf:"varint,3,opt,name=sizeOfHeadersBytes,proto3" json:"sizeOfHeadersBytes,omitempty"`
	SizeOfBodyBytes    uint64 `protobuf:"varint,4,opt,name=sizeOfBodyBytes,proto3" json:"sizeOfBodyBytes,omitempty"`
}

func (x *AccessLogHTTPProtocolResponse) Reset() {
	*x = AccessLogHTTPProtocolResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogHTTPProtocolResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogHTTPProtocolResponse) ProtoMessage() {}

func (x *AccessLogHTTPProtocolResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogHTTPProtocolResponse.ProtoReflect.Descriptor instead.
func (*AccessLogHTTPProtocolResponse) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{14}
}

func (x *AccessLogHTTPProtocolResponse) GetStatusCode() int32 {
	if x != nil {
		return x.StatusCode
	}
	return 0
}

func (x *AccessLogHTTPProtocolResponse) GetSizeOfHeadersBytes() uint64 {
	if x != nil {
		return x.SizeOfHeadersBytes
	}
	return 0
}

func (x *AccessLogHTTPProtocolResponse) GetSizeOfBodyBytes() uint64 {
	if x != nil {
		return x.SizeOfBodyBytes
	}
	return 0
}

type AccessLogTraceInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Provider AccessLogTraceInfoProvider `protobuf:"varint,1,opt,name=provider,proto3,enum=skywalking.v3.AccessLogTraceInfoProvider" json:"provider,omitempty"`
	// [Optional] A string id represents the whole trace.
	TraceId string `protobuf:"bytes,2,opt,name=traceId,proto3" json:"traceId,omitempty"`
	// A unique id represents this segment. Other segments could use this id to reference as a child segment.
	// [Optional] when this span reference
	TraceSegmentId string `protobuf:"bytes,3,opt,name=traceSegmentId,proto3" json:"traceSegmentId,omitempty"`
	// If type == SkyWalking
	// The number id of the span. Should be unique in the whole segment.
	// Starting at 0
	//
	// If type == Zipkin
	// The type of span ID is string.
	SpanId string `protobuf:"bytes,4,opt,name=spanId,proto3" json:"spanId,omitempty"`
}

func (x *AccessLogTraceInfo) Reset() {
	*x = AccessLogTraceInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogTraceInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogTraceInfo) ProtoMessage() {}

func (x *AccessLogTraceInfo) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogTraceInfo.ProtoReflect.Descriptor instead.
func (*AccessLogTraceInfo) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{15}
}

func (x *AccessLogTraceInfo) GetProvider() AccessLogTraceInfoProvider {
	if x != nil {
		return x.Provider
	}
	return AccessLogTraceInfoProvider_Zipkin
}

func (x *AccessLogTraceInfo) GetTraceId() string {
	if x != nil {
		return x.TraceId
	}
	return ""
}

func (x *AccessLogTraceInfo) GetTraceSegmentId() string {
	if x != nil {
		return x.TraceSegmentId
	}
	return ""
}

func (x *AccessLogTraceInfo) GetSpanId() string {
	if x != nil {
		return x.SpanId
	}
	return ""
}

type AccessLogKernelConnectOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Starting to connect with peer address timestamp
	StartTime *EBPFTimestamp `protobuf:"bytes,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Finish connect operation timestamp
	EndTime *EBPFTimestamp `protobuf:"bytes,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	// Is the connect operation success or not
	Success bool `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
}

func (x *AccessLogKernelConnectOperation) Reset() {
	*x = AccessLogKernelConnectOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelConnectOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelConnectOperation) ProtoMessage() {}

func (x *AccessLogKernelConnectOperation) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelConnectOperation.ProtoReflect.Descriptor instead.
func (*AccessLogKernelConnectOperation) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{16}
}

func (x *AccessLogKernelConnectOperation) GetStartTime() *EBPFTimestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *AccessLogKernelConnectOperation) GetEndTime() *EBPFTimestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *AccessLogKernelConnectOperation) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

type AccessLogKernelAcceptOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Starting to accept socket timestamp
	StartTime *EBPFTimestamp `protobuf:"bytes,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Finish accept operation timestamp
	EndTime *EBPFTimestamp `protobuf:"bytes,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (x *AccessLogKernelAcceptOperation) Reset() {
	*x = AccessLogKernelAcceptOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelAcceptOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelAcceptOperation) ProtoMessage() {}

func (x *AccessLogKernelAcceptOperation) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelAcceptOperation.ProtoReflect.Descriptor instead.
func (*AccessLogKernelAcceptOperation) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{17}
}

func (x *AccessLogKernelAcceptOperation) GetStartTime() *EBPFTimestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *AccessLogKernelAcceptOperation) GetEndTime() *EBPFTimestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

type AccessLogKernelCloseOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Starting to close the connection timestamp
	StartTime *EBPFTimestamp `protobuf:"bytes,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Finish close operation timestamp
	EndTime *EBPFTimestamp `protobuf:"bytes,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	// Is the close operation success or not
	Success bool `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
}

func (x *AccessLogKernelCloseOperation) Reset() {
	*x = AccessLogKernelCloseOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelCloseOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelCloseOperation) ProtoMessage() {}

func (x *AccessLogKernelCloseOperation) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelCloseOperation.ProtoReflect.Descriptor instead.
func (*AccessLogKernelCloseOperation) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{18}
}

func (x *AccessLogKernelCloseOperation) GetStartTime() *EBPFTimestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *AccessLogKernelCloseOperation) GetEndTime() *EBPFTimestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *AccessLogKernelCloseOperation) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

type AccessLogKernelWriteOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Starting to write data timestamp
	StartTime *EBPFTimestamp `protobuf:"bytes,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Finish write operation timestamp
	EndTime *EBPFTimestamp `protobuf:"bytes,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	// Which kind of syscall of current write operation
	Syscall AccessLogKernelWriteSyscall `protobuf:"varint,3,opt,name=syscall,proto3,enum=skywalking.v3.AccessLogKernelWriteSyscall" json:"syscall,omitempty"`
	// Layer 2-4 related metrics
	L4Metrics *AccessLogKernelWriteL4Metrics `protobuf:"bytes,4,opt,name=l4Metrics,proto3" json:"l4Metrics,omitempty"`
	L3Metrics *AccessLogKernelWriteL3Metrics `protobuf:"bytes,5,opt,name=l3Metrics,proto3" json:"l3Metrics,omitempty"`
	L2Metrics *AccessLogKernelWriteL2Metrics `protobuf:"bytes,6,opt,name=l2Metrics,proto3" json:"l2Metrics,omitempty"`
}

func (x *AccessLogKernelWriteOperation) Reset() {
	*x = AccessLogKernelWriteOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelWriteOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelWriteOperation) ProtoMessage() {}

func (x *AccessLogKernelWriteOperation) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelWriteOperation.ProtoReflect.Descriptor instead.
func (*AccessLogKernelWriteOperation) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{19}
}

func (x *AccessLogKernelWriteOperation) GetStartTime() *EBPFTimestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *AccessLogKernelWriteOperation) GetEndTime() *EBPFTimestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *AccessLogKernelWriteOperation) GetSyscall() AccessLogKernelWriteSyscall {
	if x != nil {
		return x.Syscall
	}
	return AccessLogKernelWriteSyscall_Write
}

func (x *AccessLogKernelWriteOperation) GetL4Metrics() *AccessLogKernelWriteL4Metrics {
	if x != nil {
		return x.L4Metrics
	}
	return nil
}

func (x *AccessLogKernelWriteOperation) GetL3Metrics() *AccessLogKernelWriteL3Metrics {
	if x != nil {
		return x.L3Metrics
	}
	return nil
}

func (x *AccessLogKernelWriteOperation) GetL2Metrics() *AccessLogKernelWriteL2Metrics {
	if x != nil {
		return x.L2Metrics
	}
	return nil
}

type AccessLogKernelWriteL4Metrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// total duration(nanosecond) of layer 4
	TotalDuration uint64 `protobuf:"varint,1,opt,name=totalDuration,proto3" json:"totalDuration,omitempty"`
	// total send package(contains retransmit count) count(sk_buff in linux)
	TotalTransmitPackageCount int64 `protobuf:"varint,2,opt,name=totalTransmitPackageCount,proto3" json:"totalTransmitPackageCount,omitempty"`
	// total retransmit package count(sk_buff in linux)
	TotalRetransmitPackageCount int64 `protobuf:"varint,3,opt,name=totalRetransmitPackageCount,proto3" json:"totalRetransmitPackageCount,omitempty"`
	// total losted package count metrics
	LossPackageMetrics []*AccessLogLossPackageMetrics `protobuf:"bytes,4,rep,name=lossPackageMetrics,proto3" json:"lossPackageMetrics,omitempty"`
	// total package size(bytes)
	TotalPackageSize int64 `protobuf:"varint,5,opt,name=totalPackageSize,proto3" json:"totalPackageSize,omitempty"`
}

func (x *AccessLogKernelWriteL4Metrics) Reset() {
	*x = AccessLogKernelWriteL4Metrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelWriteL4Metrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelWriteL4Metrics) ProtoMessage() {}

func (x *AccessLogKernelWriteL4Metrics) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelWriteL4Metrics.ProtoReflect.Descriptor instead.
func (*AccessLogKernelWriteL4Metrics) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{20}
}

func (x *AccessLogKernelWriteL4Metrics) GetTotalDuration() uint64 {
	if x != nil {
		return x.TotalDuration
	}
	return 0
}

func (x *AccessLogKernelWriteL4Metrics) GetTotalTransmitPackageCount() int64 {
	if x != nil {
		return x.TotalTransmitPackageCount
	}
	return 0
}

func (x *AccessLogKernelWriteL4Metrics) GetTotalRetransmitPackageCount() int64 {
	if x != nil {
		return x.TotalRetransmitPackageCount
	}
	return 0
}

func (x *AccessLogKernelWriteL4Metrics) GetLossPackageMetrics() []*AccessLogLossPackageMetrics {
	if x != nil {
		return x.LossPackageMetrics
	}
	return nil
}

func (x *AccessLogKernelWriteL4Metrics) GetTotalPackageSize() int64 {
	if x != nil {
		return x.TotalPackageSize
	}
	return 0
}

type AccessLogLossPackageMetrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Location string `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Count    int32  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (x *AccessLogLossPackageMetrics) Reset() {
	*x = AccessLogLossPackageMetrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogLossPackageMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogLossPackageMetrics) ProtoMessage() {}

func (x *AccessLogLossPackageMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogLossPackageMetrics.ProtoReflect.Descriptor instead.
func (*AccessLogLossPackageMetrics) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{21}
}

func (x *AccessLogLossPackageMetrics) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

func (x *AccessLogLossPackageMetrics) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

type AccessLogKernelWriteL3Metrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// total duration(nanosecond) of layer 3
	TotalDuration uint64 `protobuf:"varint,1,opt,name=totalDuration,proto3" json:"totalDuration,omitempty"`
	// total local out use duration(nanoseconds) -> kernel: ip_local_out
	TotalLocalDuration uint64 `protobuf:"varint,2,opt,name=totalLocalDuration,proto3" json:"totalLocalDuration,omitempty"`
	// total output use duration(nanoseconds) -> kernel: ip_finish_output2 - ip_output
	TotalOutputDuration uint64 `protobuf:"varint,3,opt,name=totalOutputDuration,proto3" json:"totalOutputDuration,omitempty"`
	// total resolve remote MAC address(ARP Request) count and duration(nanosecond) -> kernel: neigh_resolve_output
	TotalResolveMACCount    uint64 `protobuf:"varint,5,opt,name=totalResolveMACCount,proto3" json:"totalResolveMACCount,omitempty"`
	TotalResolveMACDuration uint64 `protobuf:"varint,6,opt,name=totalResolveMACDuration,proto3" json:"totalResolveMACDuration,omitempty"`
	// total netfiltering count and duration(nanosecond) -> kernel: nf_hook
	TotalNetFilterCount    uint64 `protobuf:"varint,7,opt,name=totalNetFilterCount,proto3" json:"totalNetFilterCount,omitempty"`
	TotalNetFilterDuration uint64 `protobuf:"varint,8,opt,name=totalNetFilterDuration,proto3" json:"totalNetFilterDuration,omitempty"`
}

func (x *AccessLogKernelWriteL3Metrics) Reset() {
	*x = AccessLogKernelWriteL3Metrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelWriteL3Metrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelWriteL3Metrics) ProtoMessage() {}

func (x *AccessLogKernelWriteL3Metrics) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelWriteL3Metrics.ProtoReflect.Descriptor instead.
func (*AccessLogKernelWriteL3Metrics) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{22}
}

func (x *AccessLogKernelWriteL3Metrics) GetTotalDuration() uint64 {
	if x != nil {
		return x.TotalDuration
	}
	return 0
}

func (x *AccessLogKernelWriteL3Metrics) GetTotalLocalDuration() uint64 {
	if x != nil {
		return x.TotalLocalDuration
	}
	return 0
}

func (x *AccessLogKernelWriteL3Metrics) GetTotalOutputDuration() uint64 {
	if x != nil {
		return x.TotalOutputDuration
	}
	return 0
}

func (x *AccessLogKernelWriteL3Metrics) GetTotalResolveMACCount() uint64 {
	if x != nil {
		return x.TotalResolveMACCount
	}
	return 0
}

func (x *AccessLogKernelWriteL3Metrics) GetTotalResolveMACDuration() uint64 {
	if x != nil {
		return x.TotalResolveMACDuration
	}
	return 0
}

func (x *AccessLogKernelWriteL3Metrics) GetTotalNetFilterCount() uint64 {
	if x != nil {
		return x.TotalNetFilterCount
	}
	return 0
}

func (x *AccessLogKernelWriteL3Metrics) GetTotalNetFilterDuration() uint64 {
	if x != nil {
		return x.TotalNetFilterDuration
	}
	return 0
}

type AccessLogKernelWriteL2Metrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// total duration(nanosecond) of layer 2
	TotalDuration uint64 `protobuf:"varint,1,opt,name=totalDuration,proto3" json:"totalDuration,omitempty"`
	// target network hardware interface index, get the net hardware name through EBPFAccessLogNodeNetInterface#index
	Ifindex uint32 `protobuf:"varint,2,opt,name=ifindex,proto3" json:"ifindex,omitempty"`
	// total enter the net device buffer count
	TotalEnterQueueBufferCount uint64 `protobuf:"varint,3,opt,name=totalEnterQueueBufferCount,proto3" json:"totalEnterQueueBufferCount,omitempty"`
	// total buffer data ready to send duration(nanosecond), ready_to_send - enter_queue
	TotalReadySendDuration uint64 `protobuf:"varint,4,opt,name=totalReadySendDuration,proto3" json:"totalReadySendDuration,omitempty"`
	// total send buffer to the net device duration(nanosecond)
	TotalNetDeviceSendDuration uint64 `protobuf:"varint,5,opt,name=totalNetDeviceSendDuration,proto3" json:"totalNetDeviceSendDuration,omitempty"`
}

func (x *AccessLogKernelWriteL2Metrics) Reset() {
	*x = AccessLogKernelWriteL2Metrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelWriteL2Metrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelWriteL2Metrics) ProtoMessage() {}

func (x *AccessLogKernelWriteL2Metrics) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelWriteL2Metrics.ProtoReflect.Descriptor instead.
func (*AccessLogKernelWriteL2Metrics) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{23}
}

func (x *AccessLogKernelWriteL2Metrics) GetTotalDuration() uint64 {
	if x != nil {
		return x.TotalDuration
	}
	return 0
}

func (x *AccessLogKernelWriteL2Metrics) GetIfindex() uint32 {
	if x != nil {
		return x.Ifindex
	}
	return 0
}

func (x *AccessLogKernelWriteL2Metrics) GetTotalEnterQueueBufferCount() uint64 {
	if x != nil {
		return x.TotalEnterQueueBufferCount
	}
	return 0
}

func (x *AccessLogKernelWriteL2Metrics) GetTotalReadySendDuration() uint64 {
	if x != nil {
		return x.TotalReadySendDuration
	}
	return 0
}

func (x *AccessLogKernelWriteL2Metrics) GetTotalNetDeviceSendDuration() uint64 {
	if x != nil {
		return x.TotalNetDeviceSendDuration
	}
	return 0
}

type AccessLogKernelReadOperation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Starting to read data timestamp
	StartTime *EBPFTimestamp `protobuf:"bytes,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Finish read operation timestamp
	EndTime *EBPFTimestamp `protobuf:"bytes,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	// Which kind of syscall of current read operation
	Syscall AccessLogKernelReadSyscall `protobuf:"varint,3,opt,name=syscall,proto3,enum=skywalking.v3.AccessLogKernelReadSyscall" json:"syscall,omitempty"`
	// Layer 2-4 related metrics
	L2Metrics *AccessLogKernelReadL2Metrics `protobuf:"bytes,4,opt,name=l2Metrics,proto3" json:"l2Metrics,omitempty"`
	L3Metrics *AccessLogKernelReadL3Metrics `protobuf:"bytes,5,opt,name=l3Metrics,proto3" json:"l3Metrics,omitempty"`
	L4Metrics *AccessLogKernelReadL4Metrics `protobuf:"bytes,6,opt,name=l4Metrics,proto3" json:"l4Metrics,omitempty"`
}

func (x *AccessLogKernelReadOperation) Reset() {
	*x = AccessLogKernelReadOperation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelReadOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelReadOperation) ProtoMessage() {}

func (x *AccessLogKernelReadOperation) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelReadOperation.ProtoReflect.Descriptor instead.
func (*AccessLogKernelReadOperation) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{24}
}

func (x *AccessLogKernelReadOperation) GetStartTime() *EBPFTimestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *AccessLogKernelReadOperation) GetEndTime() *EBPFTimestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *AccessLogKernelReadOperation) GetSyscall() AccessLogKernelReadSyscall {
	if x != nil {
		return x.Syscall
	}
	return AccessLogKernelReadSyscall_Read
}

func (x *AccessLogKernelReadOperation) GetL2Metrics() *AccessLogKernelReadL2Metrics {
	if x != nil {
		return x.L2Metrics
	}
	return nil
}

func (x *AccessLogKernelReadOperation) GetL3Metrics() *AccessLogKernelReadL3Metrics {
	if x != nil {
		return x.L3Metrics
	}
	return nil
}

func (x *AccessLogKernelReadOperation) GetL4Metrics() *AccessLogKernelReadL4Metrics {
	if x != nil {
		return x.L4Metrics
	}
	return nil
}

type AccessLogKernelReadL2Metrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// from network hardware interface index, get the net hardware name through EBPFAccessLogNodeNetInterface#index
	Ifindex uint32 `protobuf:"varint,1,opt,name=ifindex,proto3" json:"ifindex,omitempty"`
	// total package count
	TotalPackageCount uint32 `protobuf:"varint,2,opt,name=totalPackageCount,proto3" json:"totalPackageCount,omitempty"`
	// total package size
	TotalPackageSize uint64 `protobuf:"varint,3,opt,name=totalPackageSize,proto3" json:"totalPackageSize,omitempty"`
	// total duration(nanosecond) of all data packets queued (waiting to be read).
	TotalPackageToQueueDuration uint64 `protobuf:"varint,4,opt,name=totalPackageToQueueDuration,proto3" json:"totalPackageToQueueDuration,omitempty"`
	// total duration(nanosecond) of all data packets read from the queue.
	TotalRcvPackageFromQueueDuration uint64 `protobuf:"varint,5,opt,name=totalRcvPackageFromQueueDuration,proto3" json:"totalRcvPackageFromQueueDuration,omitempty"`
}

func (x *AccessLogKernelReadL2Metrics) Reset() {
	*x = AccessLogKernelReadL2Metrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelReadL2Metrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelReadL2Metrics) ProtoMessage() {}

func (x *AccessLogKernelReadL2Metrics) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelReadL2Metrics.ProtoReflect.Descriptor instead.
func (*AccessLogKernelReadL2Metrics) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{25}
}

func (x *AccessLogKernelReadL2Metrics) GetIfindex() uint32 {
	if x != nil {
		return x.Ifindex
	}
	return 0
}

func (x *AccessLogKernelReadL2Metrics) GetTotalPackageCount() uint32 {
	if x != nil {
		return x.TotalPackageCount
	}
	return 0
}

func (x *AccessLogKernelReadL2Metrics) GetTotalPackageSize() uint64 {
	if x != nil {
		return x.TotalPackageSize
	}
	return 0
}

func (x *AccessLogKernelReadL2Metrics) GetTotalPackageToQueueDuration() uint64 {
	if x != nil {
		return x.TotalPackageToQueueDuration
	}
	return 0
}

func (x *AccessLogKernelReadL2Metrics) GetTotalRcvPackageFromQueueDuration() uint64 {
	if x != nil {
		return x.TotalRcvPackageFromQueueDuration
	}
	return 0
}

type AccessLogKernelReadL3Metrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TotalDuration uint64 `protobuf:"varint,1,opt,name=totalDuration,proto3" json:"totalDuration,omitempty"`
	// total local receive use duration(nanoseconds) -> kernel: ip_rcv_finish - ip_rcv
	TotalRecvDuration uint64 `protobuf:"varint,2,opt,name=totalRecvDuration,proto3" json:"totalRecvDuration,omitempty"`
	// total local use duration(nanoseconds) -> kernel: ip_local_deliver_finish - ip_local_deliver
	TotalLocalDuration uint64 `protobuf:"varint,3,opt,name=totalLocalDuration,proto3" json:"totalLocalDuration,omitempty"`
	// total netfiltering count and duration(nanosecond) -> kernel: nf_hook
	TotalNetFilterCount    uint64 `protobuf:"varint,4,opt,name=totalNetFilterCount,proto3" json:"totalNetFilterCount,omitempty"`
	TotalNetFilterDuration uint64 `protobuf:"varint,5,opt,name=totalNetFilterDuration,proto3" json:"totalNetFilterDuration,omitempty"`
}

func (x *AccessLogKernelReadL3Metrics) Reset() {
	*x = AccessLogKernelReadL3Metrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelReadL3Metrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelReadL3Metrics) ProtoMessage() {}

func (x *AccessLogKernelReadL3Metrics) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelReadL3Metrics.ProtoReflect.Descriptor instead.
func (*AccessLogKernelReadL3Metrics) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{26}
}

func (x *AccessLogKernelReadL3Metrics) GetTotalDuration() uint64 {
	if x != nil {
		return x.TotalDuration
	}
	return 0
}

func (x *AccessLogKernelReadL3Metrics) GetTotalRecvDuration() uint64 {
	if x != nil {
		return x.TotalRecvDuration
	}
	return 0
}

func (x *AccessLogKernelReadL3Metrics) GetTotalLocalDuration() uint64 {
	if x != nil {
		return x.TotalLocalDuration
	}
	return 0
}

func (x *AccessLogKernelReadL3Metrics) GetTotalNetFilterCount() uint64 {
	if x != nil {
		return x.TotalNetFilterCount
	}
	return 0
}

func (x *AccessLogKernelReadL3Metrics) GetTotalNetFilterDuration() uint64 {
	if x != nil {
		return x.TotalNetFilterDuration
	}
	return 0
}

type AccessLogKernelReadL4Metrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TotalDuration uint64 `protobuf:"varint,1,opt,name=totalDuration,proto3" json:"totalDuration,omitempty"`
}

func (x *AccessLogKernelReadL4Metrics) Reset() {
	*x = AccessLogKernelReadL4Metrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogKernelReadL4Metrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogKernelReadL4Metrics) ProtoMessage() {}

func (x *AccessLogKernelReadL4Metrics) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogKernelReadL4Metrics.ProtoReflect.Descriptor instead.
func (*AccessLogKernelReadL4Metrics) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{27}
}

func (x *AccessLogKernelReadL4Metrics) GetTotalDuration() uint64 {
	if x != nil {
		return x.TotalDuration
	}
	return 0
}

type EBPFTimestamp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Timestamp:
	//
	//	*EBPFTimestamp_Offset
	Timestamp isEBPFTimestamp_Timestamp `protobuf_oneof:"timestamp"`
}

func (x *EBPFTimestamp) Reset() {
	*x = EBPFTimestamp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EBPFTimestamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EBPFTimestamp) ProtoMessage() {}

func (x *EBPFTimestamp) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EBPFTimestamp.ProtoReflect.Descriptor instead.
func (*EBPFTimestamp) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{28}
}

func (m *EBPFTimestamp) GetTimestamp() isEBPFTimestamp_Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (x *EBPFTimestamp) GetOffset() *EBPFOffsetTimestamp {
	if x, ok := x.GetTimestamp().(*EBPFTimestamp_Offset); ok {
		return x.Offset
	}
	return nil
}

type isEBPFTimestamp_Timestamp interface {
	isEBPFTimestamp_Timestamp()
}

type EBPFTimestamp_Offset struct {
	Offset *EBPFOffsetTimestamp `protobuf:"bytes,1,opt,name=offset,proto3,oneof"`
}

func (*EBPFTimestamp_Offset) isEBPFTimestamp_Timestamp() {}

// Get nanosecond through offset with node start instant
type EBPFOffsetTimestamp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Offset uint64 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *EBPFOffsetTimestamp) Reset() {
	*x = EBPFOffsetTimestamp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EBPFOffsetTimestamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EBPFOffsetTimestamp) ProtoMessage() {}

func (x *EBPFOffsetTimestamp) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EBPFOffsetTimestamp.ProtoReflect.Descriptor instead.
func (*EBPFOffsetTimestamp) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{29}
}

func (x *EBPFOffsetTimestamp) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type EBPFAccessLogDownstream struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *EBPFAccessLogDownstream) Reset() {
	*x = EBPFAccessLogDownstream{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ebpf_accesslog_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EBPFAccessLogDownstream) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EBPFAccessLogDownstream) ProtoMessage() {}

func (x *EBPFAccessLogDownstream) ProtoReflect() protoreflect.Message {
	mi := &file_ebpf_accesslog_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EBPFAccessLogDownstream.ProtoReflect.Descriptor instead.
func (*EBPFAccessLogDownstream) Descriptor() ([]byte, []int) {
	return file_ebpf_accesslog_proto_rawDescGZIP(), []int{30}
}

var File_ebpf_accesslog_proto protoreflect.FileDescriptor

var file_ebpf_accesslog_proto_rawDesc = []byte{
	0x0a, 0x14, 0x65, 0x62, 0x70, 0x66, 0x2f, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x6c, 0x6f, 0x67,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69,
	0x6e, 0x67, 0x2e, 0x76, 0x33, 0x1a, 0x13, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x43, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x9f, 0x02, 0x0a, 0x14, 0x45,
	0x42, 0x50, 0x46, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x12, 0x38, 0x0a, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x24, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4e,
	0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x12, 0x42, 0x0a,
	0x0a, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x22, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x43, 0x6f, 0x6e, 0x6e, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x41, 0x0a, 0x0a, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x4c, 0x6f, 0x67, 0x73, 0x18,
	0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69,
	0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b,
	0x65, 0x72, 0x6e, 0x65, 0x6c, 0x4c, 0x6f, 0x67, 0x52, 0x0a, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c,
	0x4c, 0x6f, 0x67, 0x73, 0x12, 0x46, 0x0a, 0x0b, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
	0x4c, 0x6f, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x73, 0x6b, 0x79, 0x77,
	0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x4c, 0x6f, 0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x4c, 0x6f, 0x67, 0x73, 0x52,
	0x0b, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x4c, 0x6f, 0x67, 0x22, 0x91, 0x02, 0x0a,
	0x15, 0x45, 0x42, 0x50, 0x46, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4e, 0x6f,
	0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x52, 0x0a, 0x0d, 0x6e, 0x65,
	0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x2c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4e,
	0x6f, 0x64, 0x65, 0x4e, 0x65, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x52,
	0x0d, 0x6e, 0x65, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73, 0x12, 0x32,
	0x0a, 0x08, 0x62, 0x6f, 0x6f, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x16, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33,
	0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x52, 0x08, 0x62, 0x6f, 0x6f, 0x74, 0x54, 0x69,
	0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x4e, 0x61, 0x6d,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72,
	0x4e, 0x61, 0x6d, 0x65, 0x12, 0x3a, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e,
	0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c,
	0x6f, 0x67, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x22, 0x43, 0x0a, 0x13, 0x45, 0x42, 0x50, 0x46, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f,
	0x67, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x2c, 0x0a, 0x11, 0x65, 0x78, 0x63, 0x6c, 0x75,
	0x64, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x11, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x73,
	0x70, 0x61, 0x63, 0x65, 0x73, 0x22, 0x5b, 0x0a, 0x1d, 0x45, 0x42, 0x50, 0x46, 0x41, 0x63, 0x63,
	0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4e, 0x6f, 0x64, 0x65, 0x4e, 0x65, 0x74, 0x49, 0x6e, 0x74,
	0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x10, 0x0a, 0x03,
	0x6d, 0x74, 0x75, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6d, 0x74, 0x75, 0x12, 0x12,
	0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x22, 0x83, 0x03, 0x0a, 0x13, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67,
	0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x36, 0x0a, 0x05, 0x6c, 0x6f,
	0x63, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x73, 0x6b, 0x79, 0x77,
	0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x05, 0x6c, 0x6f, 0x63,
	0x61, 0x6c, 0x12, 0x38, 0x0a, 0x06, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x20, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e,
	0x76, 0x33, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x06, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x12, 0x2e, 0x0a, 0x04,
	0x72, 0x6f, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x73, 0x6b, 0x79,
	0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x44, 0x65, 0x74, 0x65, 0x63,
	0x74, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x12, 0x43, 0x0a, 0x07,
	0x74, 0x6c, 0x73, 0x4d, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x29, 0x2e,
	0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x54, 0x4c, 0x53, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x07, 0x74, 0x6c, 0x73, 0x4d, 0x6f, 0x64,
	0x65, 0x12, 0x40, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67,
	0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x12, 0x43, 0x0a, 0x0a, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e,
	0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c,
	0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0a, 0x61, 0x74,
	0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x22, 0x6e, 0x0a, 0x14, 0x43, 0x6f, 0x6e, 0x6e,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74,
	0x12, 0x47, 0x0a, 0x07, 0x7a, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2b, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x5a, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d,
	0x65, 0x6e, 0x74, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x48, 0x00,
	0x52, 0x07, 0x7a, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x42, 0x0d, 0x0a, 0x0b, 0x65, 0x6e, 0x76,
	0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x22, 0xec, 0x01, 0x0a, 0x1c, 0x5a, 0x54, 0x75,
	0x6e, 0x6e, 0x65, 0x6c, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e,
	0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x2e, 0x0a, 0x13, 0x72, 0x65, 0x61,
	0x6c, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x70,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x72, 0x65, 0x61, 0x6c, 0x44, 0x65, 0x73, 0x74,
	0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x70, 0x12, 0x43, 0x0a, 0x02, 0x62, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x33, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69,
	0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x5a, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x41, 0x74, 0x74,
	0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65,
	0x6e, 0x74, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x42, 0x79, 0x52, 0x02, 0x62, 0x79, 0x12, 0x57,
	0x0a, 0x0f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2e, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c,
	0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x5a, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x41,
	0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
	0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x0e, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
	0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x22, 0x95, 0x01, 0x0a, 0x11, 0x43, 0x6f, 0x6e, 0x6e,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x49, 0x0a,
	0x0a, 0x6b, 0x75, 0x62, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x27, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x4b, 0x75, 0x62, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x65, 0x73, 0x50, 0x72, 0x6f, 0x63,
	0x65, 0x73, 0x73, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x48, 0x00, 0x52, 0x0a, 0x6b, 0x75,
	0x62, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x65, 0x73, 0x12, 0x2a, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e,
	0x67, 0x2e, 0x76, 0x33, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x48, 0x00,
	0x52, 0x02, 0x69, 0x70, 0x42, 0x09, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22,
	0xb2, 0x01, 0x0a, 0x18, 0x4b, 0x75, 0x62, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x65, 0x73, 0x50, 0x72,
	0x6f, 0x63, 0x65, 0x73, 0x73, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x20, 0x0a, 0x0b,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x18,
	0x0a, 0x07, 0x70, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x70, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x24, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74,
	0x61, 0x69, 0x6e, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x20,
	0x0a, 0x0b, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x4e, 0x61, 0x6d, 0x65,
	0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04,
	0x70, 0x6f, 0x72, 0x74, 0x22, 0x33, 0x0a, 0x09, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x68, 0x6f, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x22, 0x85, 0x03, 0x0a, 0x12, 0x41, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x4c, 0x6f, 0x67,
	0x12, 0x4a, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2e, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65,
	0x6c, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x48, 0x00, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x12, 0x47, 0x0a, 0x06,
	0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x73,
	0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63,
	0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x41, 0x63, 0x63, 0x65,
	0x70, 0x74, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x06, 0x61,
	0x63, 0x63, 0x65, 0x70, 0x74, 0x12, 0x44, 0x0a, 0x05, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e,
	0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65,
	0x72, 0x6e, 0x65, 0x6c, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x48, 0x00, 0x52, 0x05, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x12, 0x41, 0x0a, 0x04, 0x72,
	0x65, 0x61, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x73, 0x6b, 0x79, 0x77,
	0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x61, 0x64, 0x4f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x04, 0x72, 0x65, 0x61, 0x64, 0x12, 0x44,
	0x0a, 0x05, 0x77, 0x72, 0x69, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e,
	0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x57, 0x72, 0x69,
	0x74, 0x65, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x05, 0x77,
	0x72, 0x69, 0x74, 0x65, 0x42, 0x0b, 0x0a, 0x09, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x22, 0x5f, 0x0a, 0x15, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x4c, 0x6f, 0x67, 0x73, 0x12, 0x3a, 0x0a, 0x04, 0x68, 0x74,
	0x74, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61,
	0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c,
	0x6f, 0x67, 0x48, 0x54, 0x54, 0x50, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x48, 0x00,
	0x52, 0x04, 0x68, 0x74, 0x74, 0x70, 0x42, 0x0a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x22, 0xe3, 0x02, 0x0a, 0x15, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67,
	0x48, 0x54, 0x54, 0x50, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x3a, 0x0a, 0x09,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e,
	0x45, 0x42, 0x50, 0x46, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73,
	0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x65, 0x6e, 0x64, 0x54,
	0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b, 0x79, 0x77,
	0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x54, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65,
	0x12, 0x45, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x2b, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x48, 0x54, 0x54, 0x50, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x07,
	0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x45, 0x0a, 0x07, 0x72, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61,
	0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c,
	0x6f, 0x67, 0x48, 0x54, 0x54, 0x50, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x07, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x48,
	0x0a, 0x08, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33,
	0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x48, 0x54, 0x54, 0x50, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x08,
	0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0xa4, 0x02, 0x0a, 0x1c, 0x41, 0x63, 0x63,
	0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x48, 0x54, 0x54, 0x50, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x49, 0x0a, 0x06, 0x6d, 0x65, 0x74,
	0x68, 0x6f, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x31, 0x2e, 0x73, 0x6b, 0x79, 0x77,
	0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x4c, 0x6f, 0x67, 0x48, 0x54, 0x54, 0x50, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x52, 0x06, 0x6d, 0x65,
	0x74, 0x68, 0x6f, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x12, 0x2e, 0x0a, 0x12, 0x73, 0x69, 0x7a, 0x65,
	0x4f, 0x66, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x42, 0x79, 0x74, 0x65, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x12, 0x73, 0x69, 0x7a, 0x65, 0x4f, 0x66, 0x48, 0x65, 0x61, 0x64,
	0x65, 0x72, 0x73, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x28, 0x0a, 0x0f, 0x73, 0x69, 0x7a, 0x65,
	0x4f, 0x66, 0x42, 0x6f, 0x64, 0x79, 0x42, 0x79, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x0f, 0x73, 0x69, 0x7a, 0x65, 0x4f, 0x66, 0x42, 0x6f, 0x64, 0x79, 0x42, 0x79, 0x74,
	0x65, 0x73, 0x12, 0x37, 0x0a, 0x05, 0x74, 0x72, 0x61, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x21, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x54, 0x72, 0x61, 0x63, 0x65,
	0x49, 0x6e, 0x66, 0x6f, 0x52, 0x05, 0x74, 0x72, 0x61, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x68,
	0x6f, 0x73, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x22,
	0x99, 0x01, 0x0a, 0x1d, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x48, 0x54, 0x54,
	0x50, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64,
	0x65, 0x12, 0x2e, 0x0a, 0x12, 0x73, 0x69, 0x7a, 0x65, 0x4f, 0x66, 0x48, 0x65, 0x61, 0x64, 0x65,
	0x72, 0x73, 0x42, 0x79, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x12, 0x73,
	0x69, 0x7a, 0x65, 0x4f, 0x66, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x42, 0x79, 0x74, 0x65,
	0x73, 0x12, 0x28, 0x0a, 0x0f, 0x73, 0x69, 0x7a, 0x65, 0x4f, 0x66, 0x42, 0x6f, 0x64, 0x79, 0x42,
	0x79, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x73, 0x69, 0x7a, 0x65,
	0x4f, 0x66, 0x42, 0x6f, 0x64, 0x79, 0x42, 0x79, 0x74, 0x65, 0x73, 0x22, 0xb5, 0x01, 0x0a, 0x12,
	0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x54, 0x72, 0x61, 0x63, 0x65, 0x49, 0x6e,
	0x66, 0x6f, 0x12, 0x45, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x29, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e,
	0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x54, 0x72,
	0x61, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x52,
	0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x72, 0x61,
	0x63, 0x65, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x74, 0x72, 0x61, 0x63,
	0x65, 0x49, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x63, 0x65, 0x53, 0x65, 0x67, 0x6d,
	0x65, 0x6e, 0x74, 0x49, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x72, 0x61,
	0x63, 0x65, 0x53, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x73,
	0x70, 0x61, 0x6e, 0x49, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x70, 0x61,
	0x6e, 0x49, 0x64, 0x22, 0xaf, 0x01, 0x0a, 0x1f, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f,
	0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3a, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x54, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b, 0x79,
	0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x54,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54,
	0x69, 0x6d, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e,
	0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73,
	0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x22, 0x94, 0x01, 0x0a, 0x1e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x4f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3a, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x72,
	0x74, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b,
	0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x54, 0x69, 0x6d, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69,
	0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x22, 0xad, 0x01, 0x0a,
	0x1d, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c,
	0x43, 0x6c, 0x6f, 0x73, 0x65, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3a,
	0x0a, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
	0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x65, 0x6e,
	0x64, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b,
	0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69,
	0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x22, 0xbd, 0x03, 0x0a,
	0x1d, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c,
	0x57, 0x72, 0x69, 0x74, 0x65, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3a,
	0x0a, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
	0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x65, 0x6e,
	0x64, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b,
	0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69,
	0x6d, 0x65, 0x12, 0x44, 0x0a, 0x07, 0x73, 0x79, 0x73, 0x63, 0x61, 0x6c, 0x6c, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x2a, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67,
	0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72,
	0x6e, 0x65, 0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x53, 0x79, 0x73, 0x63, 0x61, 0x6c, 0x6c, 0x52,
	0x07, 0x73, 0x79, 0x73, 0x63, 0x61, 0x6c, 0x6c, 0x12, 0x4a, 0x0a, 0x09, 0x6c, 0x34, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x73, 0x6b,
	0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65,
	0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x57, 0x72, 0x69, 0x74, 0x65,
	0x4c, 0x34, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x09, 0x6c, 0x34, 0x4d, 0x65, 0x74,
	0x72, 0x69, 0x63, 0x73, 0x12, 0x4a, 0x0a, 0x09, 0x6c, 0x33, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63,
	0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c,
	0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f,
	0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x4c, 0x33, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x09, 0x6c, 0x33, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73,
	0x12, 0x4a, 0x0a, 0x09, 0x6c, 0x32, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67,
	0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72,
	0x6e, 0x65, 0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x4c, 0x32, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63,
	0x73, 0x52, 0x09, 0x6c, 0x32, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x22, 0xcd, 0x02, 0x0a,
	0x1d, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c,
	0x57, 0x72, 0x69, 0x74, 0x65, 0x4c, 0x34, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x24,
	0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3c, 0x0a, 0x19, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x54, 0x72, 0x61,
	0x6e, 0x73, 0x6d, 0x69, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x19, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x6d, 0x69, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x75,
	0x6e, 0x74, 0x12, 0x40, 0x0a, 0x1b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x74, 0x72, 0x61,
	0x6e, 0x73, 0x6d, 0x69, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x1b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65,
	0x74, 0x72, 0x61, 0x6e, 0x73, 0x6d, 0x69, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x43,
	0x6f, 0x75, 0x6e, 0x74, 0x12, 0x5a, 0x0a, 0x12, 0x6c, 0x6f, 0x73, 0x73, 0x50, 0x61, 0x63, 0x6b,
	0x61, 0x67, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2a, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33,
	0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4c, 0x6f, 0x73, 0x73, 0x50, 0x61,
	0x63, 0x6b, 0x61, 0x67, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x12, 0x6c, 0x6f,
	0x73, 0x73, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73,
	0x12, 0x2a, 0x0a, 0x10, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
	0x53, 0x69, 0x7a, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x10, 0x74, 0x6f, 0x74, 0x61,
	0x6c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x22, 0x4f, 0x0a, 0x1b,
	0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4c, 0x6f, 0x73, 0x73, 0x50, 0x61, 0x63,
	0x6b, 0x61, 0x67, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x6c,
	0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c,
	0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0xff, 0x02,
	0x0a, 0x1d, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65,
	0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x4c, 0x33, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12,
	0x24, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x75, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x12, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4c, 0x6f,
	0x63, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x12, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x44, 0x75, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x30, 0x0a, 0x13, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4f, 0x75,
	0x74, 0x70, 0x75, 0x74, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x13, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x44,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x32, 0x0a, 0x14, 0x74, 0x6f, 0x74, 0x61, 0x6c,
	0x52, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x4d, 0x41, 0x43, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x14, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x73, 0x6f,
	0x6c, 0x76, 0x65, 0x4d, 0x41, 0x43, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x38, 0x0a, 0x17, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x4d, 0x41, 0x43, 0x44, 0x75,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x52, 0x17, 0x74, 0x6f,
	0x74, 0x61, 0x6c, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x4d, 0x41, 0x43, 0x44, 0x75, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x30, 0x0a, 0x13, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4e, 0x65,
	0x74, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x13, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4e, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x74,
	0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x36, 0x0a, 0x16, 0x74, 0x6f, 0x74, 0x61, 0x6c,
	0x4e, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x16, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4e, 0x65,
	0x74, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22,
	0x97, 0x02, 0x0a, 0x1d, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72,
	0x6e, 0x65, 0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x4c, 0x32, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63,
	0x73, 0x12, 0x24, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x69, 0x66, 0x69, 0x6e, 0x64,
	0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x69, 0x66, 0x69, 0x6e, 0x64, 0x65,
	0x78, 0x12, 0x3e, 0x0a, 0x1a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x65, 0x72, 0x51,
	0x75, 0x65, 0x75, 0x65, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x1a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x65,
	0x72, 0x51, 0x75, 0x65, 0x75, 0x65, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x12, 0x36, 0x0a, 0x16, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x61, 0x64, 0x79, 0x53,
	0x65, 0x6e, 0x64, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x16, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x61, 0x64, 0x79, 0x53, 0x65, 0x6e,
	0x64, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3e, 0x0a, 0x1a, 0x74, 0x6f, 0x74,
	0x61, 0x6c, 0x4e, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x6e, 0x64, 0x44,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x1a, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x4e, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x6e,
	0x64, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0xb8, 0x03, 0x0a, 0x1c, 0x41, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x61,
	0x64, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3a, 0x0a, 0x09, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e,
	0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42,
	0x50, 0x46, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73, 0x74, 0x61,
	0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c,
	0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x43,
	0x0a, 0x07, 0x73, 0x79, 0x73, 0x63, 0x61, 0x6c, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x29, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e,
	0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52,
	0x65, 0x61, 0x64, 0x53, 0x79, 0x73, 0x63, 0x61, 0x6c, 0x6c, 0x52, 0x07, 0x73, 0x79, 0x73, 0x63,
	0x61, 0x6c, 0x6c, 0x12, 0x49, 0x0a, 0x09, 0x6c, 0x32, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b,
	0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67,
	0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x61, 0x64, 0x4c, 0x32, 0x4d, 0x65, 0x74, 0x72,
	0x69, 0x63, 0x73, 0x52, 0x09, 0x6c, 0x32, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x49,
	0x0a, 0x09, 0x6c, 0x33, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2b, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76,
	0x33, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65,
	0x6c, 0x52, 0x65, 0x61, 0x64, 0x4c, 0x33, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x09,
	0x6c, 0x33, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x49, 0x0a, 0x09, 0x6c, 0x34, 0x4d,
	0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x73,
	0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x41, 0x63, 0x63,
	0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x61, 0x64,
	0x4c, 0x34, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x09, 0x6c, 0x34, 0x4d, 0x65, 0x74,
	0x72, 0x69, 0x63, 0x73, 0x22, 0xa0, 0x02, 0x0a, 0x1c, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c,
	0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x61, 0x64, 0x4c, 0x32, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x69, 0x66, 0x69, 0x6e, 0x64, 0x65, 0x78,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x69, 0x66, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x12,
	0x2c, 0x0a, 0x11, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x43,
	0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x74, 0x6f, 0x74, 0x61,
	0x6c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x2a, 0x0a,
	0x10, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x53, 0x69, 0x7a,
	0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x10, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x50, 0x61,
	0x63, 0x6b, 0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x40, 0x0a, 0x1b, 0x74, 0x6f, 0x74,
	0x61, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x51, 0x75, 0x65, 0x75, 0x65,
	0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x1b,
	0x74, 0x6f, 0x74, 0x61, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x51, 0x75,
	0x65, 0x75, 0x65, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x4a, 0x0a, 0x20, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x52, 0x63, 0x76, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x46, 0x72,
	0x6f, 0x6d, 0x51, 0x75, 0x65, 0x75, 0x65, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x20, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x63, 0x76, 0x50,
	0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x51, 0x75, 0x65, 0x75, 0x65, 0x44,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x8c, 0x02, 0x0a, 0x1c, 0x41, 0x63, 0x63, 0x65,
	0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x61, 0x64, 0x4c,
	0x33, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x24, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61,
	0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2c,
	0x0a, 0x11, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x76, 0x44, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x11, 0x74, 0x6f, 0x74, 0x61, 0x6c,
	0x52, 0x65, 0x63, 0x76, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x12,
	0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x12, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4c,
	0x6f, 0x63, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x30, 0x0a, 0x13,
	0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4e, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x43, 0x6f,
	0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x13, 0x74, 0x6f, 0x74, 0x61, 0x6c,
	0x4e, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x36,
	0x0a, 0x16, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4e, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72,
	0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x16,
	0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4e, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x44, 0x75,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x44, 0x0a, 0x1c, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x61, 0x64, 0x4c, 0x34, 0x4d,
	0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x24, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x5a, 0x0a, 0x0d,
	0x45, 0x42, 0x50, 0x46, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x3c, 0x0a,
	0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e,
	0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42,
	0x50, 0x46, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x48, 0x00, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x42, 0x0b, 0x0a, 0x09, 0x74,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x2d, 0x0a, 0x13, 0x45, 0x42, 0x50, 0x46,
	0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
	0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x19, 0x0a, 0x17, 0x45, 0x42, 0x50, 0x46, 0x41,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x44, 0x6f, 0x77, 0x6e, 0x73, 0x74, 0x72, 0x65,
	0x61, 0x6d, 0x2a, 0x5b, 0x0a, 0x24, 0x5a, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x41, 0x74, 0x74,
	0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65,
	0x6e, 0x74, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x42, 0x79, 0x12, 0x19, 0x0a, 0x15, 0x5a, 0x54,
	0x55, 0x4e, 0x4e, 0x45, 0x4c, 0x5f, 0x4f, 0x55, 0x54, 0x42, 0x4f, 0x55, 0x4e, 0x44, 0x5f, 0x46,
	0x55, 0x4e, 0x43, 0x10, 0x00, 0x12, 0x18, 0x0a, 0x14, 0x5a, 0x54, 0x55, 0x4e, 0x4e, 0x45, 0x4c,
	0x5f, 0x49, 0x4e, 0x42, 0x4f, 0x55, 0x4e, 0x44, 0x5f, 0x46, 0x55, 0x4e, 0x43, 0x10, 0x01, 0x2a,
	0x35, 0x0a, 0x1f, 0x5a, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68,
	0x6d, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x12, 0x08, 0x0a, 0x04, 0x4d, 0x54, 0x4c, 0x53, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04,
	0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x01, 0x2a, 0x30, 0x0a, 0x1a, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x4c, 0x6f, 0x67, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x4c, 0x53,
	0x4d, 0x6f, 0x64, 0x65, 0x12, 0x09, 0x0a, 0x05, 0x50, 0x6c, 0x61, 0x69, 0x6e, 0x10, 0x00, 0x12,
	0x07, 0x0a, 0x03, 0x54, 0x4c, 0x53, 0x10, 0x01, 0x2a, 0x34, 0x0a, 0x1c, 0x41, 0x63, 0x63, 0x65,
	0x73, 0x73, 0x4c, 0x6f, 0x67, 0x48, 0x54, 0x54, 0x50, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
	0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x09, 0x0a, 0x05, 0x48, 0x54, 0x54, 0x50,
	0x31, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x48, 0x54, 0x54, 0x50, 0x32, 0x10, 0x01, 0x2a, 0x38,
	0x0a, 0x1a, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x54, 0x72, 0x61, 0x63, 0x65,
	0x49, 0x6e, 0x66, 0x6f, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x0a, 0x0a, 0x06,
	0x5a, 0x69, 0x70, 0x6b, 0x69, 0x6e, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x6b, 0x79, 0x57,
	0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x10, 0x01, 0x2a, 0x86, 0x01, 0x0a, 0x22, 0x41, 0x63, 0x63,
	0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x48, 0x54, 0x54, 0x50, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x12,
	0x07, 0x0a, 0x03, 0x47, 0x65, 0x74, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x50, 0x6f, 0x73, 0x74,
	0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x50, 0x75, 0x74, 0x10, 0x02, 0x12, 0x0a, 0x0a, 0x06, 0x44,
	0x65, 0x6c, 0x65, 0x74, 0x65, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x48, 0x65, 0x61, 0x64, 0x10,
	0x04, 0x12, 0x09, 0x0a, 0x05, 0x50, 0x61, 0x74, 0x63, 0x68, 0x10, 0x05, 0x12, 0x0b, 0x0a, 0x07,
	0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x10, 0x06, 0x12, 0x09, 0x0a, 0x05, 0x54, 0x72, 0x61,
	0x63, 0x65, 0x10, 0x07, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x10,
	0x08, 0x2a, 0x83, 0x01, 0x0a, 0x1b, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4b,
	0x65, 0x72, 0x6e, 0x65, 0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x53, 0x79, 0x73, 0x63, 0x61, 0x6c,
	0x6c, 0x12, 0x09, 0x0a, 0x05, 0x57, 0x72, 0x69, 0x74, 0x65, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06,
	0x57, 0x72, 0x69, 0x74, 0x65, 0x76, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x53, 0x65, 0x6e, 0x64,
	0x10, 0x02, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x65, 0x6e, 0x64, 0x54, 0x6f, 0x10, 0x03, 0x12, 0x0b,
	0x0a, 0x07, 0x53, 0x65, 0x6e, 0x64, 0x4d, 0x73, 0x67, 0x10, 0x04, 0x12, 0x0c, 0x0a, 0x08, 0x53,
	0x65, 0x6e, 0x64, 0x4d, 0x6d, 0x73, 0x67, 0x10, 0x05, 0x12, 0x0c, 0x0a, 0x08, 0x53, 0x65, 0x6e,
	0x64, 0x46, 0x69, 0x6c, 0x65, 0x10, 0x06, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x65, 0x6e, 0x64, 0x46,
	0x69, 0x6c, 0x65, 0x36, 0x34, 0x10, 0x07, 0x2a, 0x64, 0x0a, 0x1a, 0x41, 0x63, 0x63, 0x65, 0x73,
	0x73, 0x4c, 0x6f, 0x67, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x61, 0x64, 0x53, 0x79,
	0x73, 0x63, 0x61, 0x6c, 0x6c, 0x12, 0x08, 0x0a, 0x04, 0x52, 0x65, 0x61, 0x64, 0x10, 0x00, 0x12,
	0x09, 0x0a, 0x05, 0x52, 0x65, 0x61, 0x64, 0x76, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x52, 0x65,
	0x63, 0x76, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x65, 0x63, 0x76, 0x46, 0x72, 0x6f, 0x6d,
	0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x65, 0x63, 0x76, 0x4d, 0x73, 0x67, 0x10, 0x04, 0x12,
	0x0c, 0x0a, 0x08, 0x52, 0x65, 0x63, 0x76, 0x4d, 0x6d, 0x73, 0x67, 0x10, 0x05, 0x2a, 0x38, 0x0a,
	0x15, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43, 0x50, 0x10, 0x00, 0x12,
	0x0a, 0x0a, 0x06, 0x48, 0x54, 0x54, 0x50, 0x5f, 0x31, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x48,
	0x54, 0x54, 0x50, 0x5f, 0x32, 0x10, 0x02, 0x32, 0x72, 0x0a, 0x14, 0x45, 0x42, 0x50, 0x46, 0x41,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,
	0x5a, 0x0a, 0x07, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x12, 0x23, 0x2e, 0x73, 0x6b, 0x79,
	0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e, 0x45, 0x42, 0x50, 0x46, 0x41,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a,
	0x26, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x76, 0x33, 0x2e,
	0x45, 0x42, 0x50, 0x46, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x44, 0x6f, 0x77,
	0x6e, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x22, 0x00, 0x28, 0x01, 0x42, 0x73, 0x0a, 0x33, 0x6f,
	0x72, 0x67, 0x2e, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65, 0x2e, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c,
	0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x61, 0x70, 0x6d, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x2e, 0x65, 0x62, 0x70, 0x66, 0x2e, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x6c, 0x6f, 0x67, 0x2e,
	0x76, 0x33, 0x50, 0x01, 0x5a, 0x3a, 0x73, 0x6b, 0x79, 0x77, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67,
	0x2e, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x72, 0x65, 0x70, 0x6f,
	0x2f, 0x67, 0x6f, 0x61, 0x70, 0x69, 0x2f, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x2f, 0x65,
	0x62, 0x70, 0x66, 0x2f, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x6c, 0x6f, 0x67, 0x2f, 0x76, 0x33,
	0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_ebpf_accesslog_proto_rawDescOnce sync.Once
	file_ebpf_accesslog_proto_rawDescData = file_ebpf_accesslog_proto_rawDesc
)

func file_ebpf_accesslog_proto_rawDescGZIP() []byte {
	file_ebpf_accesslog_proto_rawDescOnce.Do(func() {
		file_ebpf_accesslog_proto_rawDescData = protoimpl.X.CompressGZIP(file_ebpf_accesslog_proto_rawDescData)
	})
	return file_ebpf_accesslog_proto_rawDescData
}

var file_ebpf_accesslog_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_ebpf_accesslog_proto_msgTypes = make([]protoimpl.MessageInfo, 31)
var file_ebpf_accesslog_proto_goTypes = []interface{}{
	(ZTunnelAttachmentEnvironmentDetectBy)(0), // 0: skywalking.v3.ZTunnelAttachmentEnvironmentDetectBy
	(ZTunnelAttachmentSecurityPolicy)(0),      // 1: skywalking.v3.ZTunnelAttachmentSecurityPolicy
	(AccessLogConnectionTLSMode)(0),           // 2: skywalking.v3.AccessLogConnectionTLSMode
	(AccessLogHTTPProtocolVersion)(0),         // 3: skywalking.v3.AccessLogHTTPProtocolVersion
	(AccessLogTraceInfoProvider)(0),           // 4: skywalking.v3.AccessLogTraceInfoProvider
	(AccessLogHTTPProtocolRequestMethod)(0),   // 5: skywalking.v3.AccessLogHTTPProtocolRequestMethod
	(AccessLogKernelWriteSyscall)(0),          // 6: skywalking.v3.AccessLogKernelWriteSyscall
	(AccessLogKernelReadSyscall)(0),           // 7: skywalking.v3.AccessLogKernelReadSyscall
	(AccessLogProtocolType)(0),                // 8: skywalking.v3.AccessLogProtocolType
	(*EBPFAccessLogMessage)(nil),              // 9: skywalking.v3.EBPFAccessLogMessage
	(*EBPFAccessLogNodeInfo)(nil),             // 10: skywalking.v3.EBPFAccessLogNodeInfo
	(*EBPFAccessLogPolicy)(nil),               // 11: skywalking.v3.EBPFAccessLogPolicy
	(*EBPFAccessLogNodeNetInterface)(nil),     // 12: skywalking.v3.EBPFAccessLogNodeNetInterface
	(*AccessLogConnection)(nil),               // 13: skywalking.v3.AccessLogConnection
	(*ConnectionAttachment)(nil),              // 14: skywalking.v3.ConnectionAttachment
	(*ZTunnelAttachmentEnvironment)(nil),      // 15: skywalking.v3.ZTunnelAttachmentEnvironment
	(*ConnectionAddress)(nil),                 // 16: skywalking.v3.ConnectionAddress
	(*KubernetesProcessAddress)(nil),          // 17: skywalking.v3.KubernetesProcessAddress
	(*IPAddress)(nil),                         // 18: skywalking.v3.IPAddress
	(*AccessLogKernelLog)(nil),                // 19: skywalking.v3.AccessLogKernelLog
	(*AccessLogProtocolLogs)(nil),             // 20: skywalking.v3.AccessLogProtocolLogs
	(*AccessLogHTTPProtocol)(nil),             // 21: skywalking.v3.AccessLogHTTPProtocol
	(*AccessLogHTTPProtocolRequest)(nil),      // 22: skywalking.v3.AccessLogHTTPProtocolRequest
	(*AccessLogHTTPProtocolResponse)(nil),     // 23: skywalking.v3.AccessLogHTTPProtocolResponse
	(*AccessLogTraceInfo)(nil),                // 24: skywalking.v3.AccessLogTraceInfo
	(*AccessLogKernelConnectOperation)(nil),   // 25: skywalking.v3.AccessLogKernelConnectOperation
	(*AccessLogKernelAcceptOperation)(nil),    // 26: skywalking.v3.AccessLogKernelAcceptOperation
	(*AccessLogKernelCloseOperation)(nil),     // 27: skywalking.v3.AccessLogKernelCloseOperation
	(*AccessLogKernelWriteOperation)(nil),     // 28: skywalking.v3.AccessLogKernelWriteOperation
	(*AccessLogKernelWriteL4Metrics)(nil),     // 29: skywalking.v3.AccessLogKernelWriteL4Metrics
	(*AccessLogLossPackageMetrics)(nil),       // 30: skywalking.v3.AccessLogLossPackageMetrics
	(*AccessLogKernelWriteL3Metrics)(nil),     // 31: skywalking.v3.AccessLogKernelWriteL3Metrics
	(*AccessLogKernelWriteL2Metrics)(nil),     // 32: skywalking.v3.AccessLogKernelWriteL2Metrics
	(*AccessLogKernelReadOperation)(nil),      // 33: skywalking.v3.AccessLogKernelReadOperation
	(*AccessLogKernelReadL2Metrics)(nil),      // 34: skywalking.v3.AccessLogKernelReadL2Metrics
	(*AccessLogKernelReadL3Metrics)(nil),      // 35: skywalking.v3.AccessLogKernelReadL3Metrics
	(*AccessLogKernelReadL4Metrics)(nil),      // 36: skywalking.v3.AccessLogKernelReadL4Metrics
	(*EBPFTimestamp)(nil),                     // 37: skywalking.v3.EBPFTimestamp
	(*EBPFOffsetTimestamp)(nil),               // 38: skywalking.v3.EBPFOffsetTimestamp
	(*EBPFAccessLogDownstream)(nil),           // 39: skywalking.v3.EBPFAccessLogDownstream
	(*v3.Instant)(nil),                        // 40: skywalking.v3.Instant
	(v3.DetectPoint)(0),                       // 41: skywalking.v3.DetectPoint
}
var file_ebpf_accesslog_proto_depIdxs = []int32{
	10, // 0: skywalking.v3.EBPFAccessLogMessage.node:type_name -> skywalking.v3.EBPFAccessLogNodeInfo
	13, // 1: skywalking.v3.EBPFAccessLogMessage.connection:type_name -> skywalking.v3.AccessLogConnection
	19, // 2: skywalking.v3.EBPFAccessLogMessage.kernelLogs:type_name -> skywalking.v3.AccessLogKernelLog
	20, // 3: skywalking.v3.EBPFAccessLogMessage.protocolLog:type_name -> skywalking.v3.AccessLogProtocolLogs
	12, // 4: skywalking.v3.EBPFAccessLogNodeInfo.netInterfaces:type_name -> skywalking.v3.EBPFAccessLogNodeNetInterface
	40, // 5: skywalking.v3.EBPFAccessLogNodeInfo.bootTime:type_name -> skywalking.v3.Instant
	11, // 6: skywalking.v3.EBPFAccessLogNodeInfo.policy:type_name -> skywalking.v3.EBPFAccessLogPolicy
	16, // 7: skywalking.v3.AccessLogConnection.local:type_name -> skywalking.v3.ConnectionAddress
	16, // 8: skywalking.v3.AccessLogConnection.remote:type_name -> skywalking.v3.ConnectionAddress
	41, // 9: skywalking.v3.AccessLogConnection.role:type_name -> skywalking.v3.DetectPoint
	2,  // 10: skywalking.v3.AccessLogConnection.tlsMode:type_name -> skywalking.v3.AccessLogConnectionTLSMode
	8,  // 11: skywalking.v3.AccessLogConnection.protocol:type_name -> skywalking.v3.AccessLogProtocolType
	14, // 12: skywalking.v3.AccessLogConnection.attachment:type_name -> skywalking.v3.ConnectionAttachment
	15, // 13: skywalking.v3.ConnectionAttachment.zTunnel:type_name -> skywalking.v3.ZTunnelAttachmentEnvironment
	0,  // 14: skywalking.v3.ZTunnelAttachmentEnvironment.by:type_name -> skywalking.v3.ZTunnelAttachmentEnvironmentDetectBy
	1,  // 15: skywalking.v3.ZTunnelAttachmentEnvironment.security_policy:type_name -> skywalking.v3.ZTunnelAttachmentSecurityPolicy
	17, // 16: skywalking.v3.ConnectionAddress.kubernetes:type_name -> skywalking.v3.KubernetesProcessAddress
	18, // 17: skywalking.v3.ConnectionAddress.ip:type_name -> skywalking.v3.IPAddress
	25, // 18: skywalking.v3.AccessLogKernelLog.connect:type_name -> skywalking.v3.AccessLogKernelConnectOperation
	26, // 19: skywalking.v3.AccessLogKernelLog.accept:type_name -> skywalking.v3.AccessLogKernelAcceptOperation
	27, // 20: skywalking.v3.AccessLogKernelLog.close:type_name -> skywalking.v3.AccessLogKernelCloseOperation
	33, // 21: skywalking.v3.AccessLogKernelLog.read:type_name -> skywalking.v3.AccessLogKernelReadOperation
	28, // 22: skywalking.v3.AccessLogKernelLog.write:type_name -> skywalking.v3.AccessLogKernelWriteOperation
	21, // 23: skywalking.v3.AccessLogProtocolLogs.http:type_name -> skywalking.v3.AccessLogHTTPProtocol
	37, // 24: skywalking.v3.AccessLogHTTPProtocol.startTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 25: skywalking.v3.AccessLogHTTPProtocol.endTime:type_name -> skywalking.v3.EBPFTimestamp
	3,  // 26: skywalking.v3.AccessLogHTTPProtocol.version:type_name -> skywalking.v3.AccessLogHTTPProtocolVersion
	22, // 27: skywalking.v3.AccessLogHTTPProtocol.request:type_name -> skywalking.v3.AccessLogHTTPProtocolRequest
	23, // 28: skywalking.v3.AccessLogHTTPProtocol.response:type_name -> skywalking.v3.AccessLogHTTPProtocolResponse
	5,  // 29: skywalking.v3.AccessLogHTTPProtocolRequest.method:type_name -> skywalking.v3.AccessLogHTTPProtocolRequestMethod
	24, // 30: skywalking.v3.AccessLogHTTPProtocolRequest.trace:type_name -> skywalking.v3.AccessLogTraceInfo
	4,  // 31: skywalking.v3.AccessLogTraceInfo.provider:type_name -> skywalking.v3.AccessLogTraceInfoProvider
	37, // 32: skywalking.v3.AccessLogKernelConnectOperation.startTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 33: skywalking.v3.AccessLogKernelConnectOperation.endTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 34: skywalking.v3.AccessLogKernelAcceptOperation.startTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 35: skywalking.v3.AccessLogKernelAcceptOperation.endTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 36: skywalking.v3.AccessLogKernelCloseOperation.startTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 37: skywalking.v3.AccessLogKernelCloseOperation.endTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 38: skywalking.v3.AccessLogKernelWriteOperation.startTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 39: skywalking.v3.AccessLogKernelWriteOperation.endTime:type_name -> skywalking.v3.EBPFTimestamp
	6,  // 40: skywalking.v3.AccessLogKernelWriteOperation.syscall:type_name -> skywalking.v3.AccessLogKernelWriteSyscall
	29, // 41: skywalking.v3.AccessLogKernelWriteOperation.l4Metrics:type_name -> skywalking.v3.AccessLogKernelWriteL4Metrics
	31, // 42: skywalking.v3.AccessLogKernelWriteOperation.l3Metrics:type_name -> skywalking.v3.AccessLogKernelWriteL3Metrics
	32, // 43: skywalking.v3.AccessLogKernelWriteOperation.l2Metrics:type_name -> skywalking.v3.AccessLogKernelWriteL2Metrics
	30, // 44: skywalking.v3.AccessLogKernelWriteL4Metrics.lossPackageMetrics:type_name -> skywalking.v3.AccessLogLossPackageMetrics
	37, // 45: skywalking.v3.AccessLogKernelReadOperation.startTime:type_name -> skywalking.v3.EBPFTimestamp
	37, // 46: skywalking.v3.AccessLogKernelReadOperation.endTime:type_name -> skywalking.v3.EBPFTimestamp
	7,  // 47: skywalking.v3.AccessLogKernelReadOperation.syscall:type_name -> skywalking.v3.AccessLogKernelReadSyscall
	34, // 48: skywalking.v3.AccessLogKernelReadOperation.l2Metrics:type_name -> skywalking.v3.AccessLogKernelReadL2Metrics
	35, // 49: skywalking.v3.AccessLogKernelReadOperation.l3Metrics:type_name -> skywalking.v3.AccessLogKernelReadL3Metrics
	36, // 50: skywalking.v3.AccessLogKernelReadOperation.l4Metrics:type_name -> skywalking.v3.AccessLogKernelReadL4Metrics
	38, // 51: skywalking.v3.EBPFTimestamp.offset:type_name -> skywalking.v3.EBPFOffsetTimestamp
	9,  // 52: skywalking.v3.EBPFAccessLogService.collect:input_type -> skywalking.v3.EBPFAccessLogMessage
	39, // 53: skywalking.v3.EBPFAccessLogService.collect:output_type -> skywalking.v3.EBPFAccessLogDownstream
	53, // [53:54] is the sub-list for method output_type
	52, // [52:53] is the sub-list for method input_type
	52, // [52:52] is the sub-list for extension type_name
	52, // [52:52] is the sub-list for extension extendee
	0,  // [0:52] is the sub-list for field type_name
}

func init() { file_ebpf_accesslog_proto_init() }
func file_ebpf_accesslog_proto_init() {
	if File_ebpf_accesslog_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_ebpf_accesslog_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EBPFAccessLogMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EBPFAccessLogNodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EBPFAccessLogPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EBPFAccessLogNodeNetInterface); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogConnection); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConnectionAttachment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ZTunnelAttachmentEnvironment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConnectionAddress); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*KubernetesProcessAddress); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPAddress); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelLog); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogProtocolLogs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogHTTPProtocol); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogHTTPProtocolRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogHTTPProtocolResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogTraceInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelConnectOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelAcceptOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelCloseOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelWriteOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelWriteL4Metrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogLossPackageMetrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelWriteL3Metrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelWriteL2Metrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelReadOperation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelReadL2Metrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelReadL3Metrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogKernelReadL4Metrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EBPFTimestamp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EBPFOffsetTimestamp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ebpf_accesslog_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EBPFAccessLogDownstream); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_ebpf_accesslog_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*ConnectionAttachment_ZTunnel)(nil),
	}
	file_ebpf_accesslog_proto_msgTypes[7].OneofWrappers = []interface{}{
		(*ConnectionAddress_Kubernetes)(nil),
		(*ConnectionAddress_Ip)(nil),
	}
	file_ebpf_accesslog_proto_msgTypes[10].OneofWrappers = []interface{}{
		(*AccessLogKernelLog_Connect)(nil),
		(*AccessLogKernelLog_Accept)(nil),
		(*AccessLogKernelLog_Close)(nil),
		(*AccessLogKernelLog_Read)(nil),
		(*AccessLogKernelLog_Write)(nil),
	}
	file_ebpf_accesslog_proto_msgTypes[11].OneofWrappers = []interface{}{
		(*AccessLogProtocolLogs_Http)(nil),
	}
	file_ebpf_accesslog_proto_msgTypes[28].OneofWrappers = []interface{}{
		(*EBPFTimestamp_Offset)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_ebpf_accesslog_proto_rawDesc,
			NumEnums:      9,
			NumMessages:   31,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_ebpf_accesslog_proto_goTypes,
		DependencyIndexes: file_ebpf_accesslog_proto_depIdxs,
		EnumInfos:         file_ebpf_accesslog_proto_enumTypes,
		MessageInfos:      file_ebpf_accesslog_proto_msgTypes,
	}.Build()
	File_ebpf_accesslog_proto = out.File
	file_ebpf_accesslog_proto_rawDesc = nil
	file_ebpf_accesslog_proto_goTypes = nil
	file_ebpf_accesslog_proto_depIdxs = nil
}
